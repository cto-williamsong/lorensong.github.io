<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="If you love life, life will love you back.">
<meta property="og:type" content="website">
<meta property="og:title" content="lorensong">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="lorensong">
<meta property="og:description" content="If you love life, life will love you back.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lorensong">
<meta name="twitter:description" content="If you love life, life will love you back.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> lorensong </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lorensong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">If you love life, life will love you back.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/10/Android-Camera-onActivityResult-null/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lorensong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lorensong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/10/Android-Camera-onActivityResult-null/" itemprop="url">
                  Android调用Camera后返回为null
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-10T15:55:48+08:00">
                2017-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="what"><a href="#what" class="headerlink" title="what?"></a>what?</h3><h3 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h3><h3 id="how"><a href="#how" class="headerlink" title="how?"></a>how?</h3><hr>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://blog.csdn.net/zimo2013/article/details/16916279" target="_blank" rel="external">Android<em>照相机Camera</em>调用系统照相机返回data为空</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/09/StatusBar/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lorensong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lorensong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/09/StatusBar/" itemprop="url">
                  StatusBar
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-09T16:05:58+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###Android状态栏完全解析</p>
<p>####引入<br>Android的状态栏后来不知怎么就称为了沉浸式状态栏,Android官方从来没有给出过沉浸式状态栏这样的命名，只有沉浸式模式（Immersive Mode）这种说法。而有些人在没有完全了解清楚沉浸模式到底是什么东西的情况下，就张冠李戴地认为一些系统提供的状态栏操作就是沉浸式的，并且还起了一个沉浸式状态栏的名字。<br>那么像饿了么的沉浸式状态栏的效果是怎么实现的呢?<br><img src="http://img.blog.csdn.net/20160820201433442" alt="沉浸式状态栏"></p>
<p>######沉浸式<br>先来分析一下叫错的原因吧，之所以很多人会叫错，是因为根本就不了解沉浸式是什么意思，然后就人云亦云跟着叫了。那么沉浸式到底是什么意思呢？<br>根据百度百科上的定义，沉浸式就是要给用户提供完全沉浸的体验，使用户有一种置身于虚拟世界之中的感觉。</p>
<p>那么对应到Android操作系统上面，怎样才算是沉浸式体验呢？这个可能在大多数情况下都是用不到的，不过在玩游戏或者看电影的时候就非常重要了。因为游戏或者影视类的应用都希望能让用户完全沉浸在其中，享受它们提供的娱乐内容，但如果这个时候在屏幕的上方还显示一个系统状态栏的话，可能就会让用户分分钟产生跳戏的感觉。<br>那么我们来看一下比较好的游戏都是怎么实现的，比如说海岛奇兵：<br><img src="http://img.blog.csdn.net/20160820201645554" alt="沉浸式具体体现"><br>海岛奇兵的这种模式就是典型的沉浸式模式，它的整个屏幕中显示都是游戏的内容，没有状态栏也没有导航栏，用户玩游戏的时候就可以完全沉浸在游戏当中，而不会被一些系统的界面元素所打扰。<br>然后我们再来看一下爱奇艺的实现：<br><img src="http://img.blog.csdn.net/20160820201922476" alt="爱奇艺的实现"><br>同样也是类似的，爱奇艺将整个屏幕作为影视的展示区，用户在看电影的时候眼中就只会有电影的内容，这样就不会被其他一些无关的东西所分心。这才是沉浸式模式的真正含义.<br>不过虽然听上去好像是很高大上的沉浸式效果，实际看上去貌似就是将内容全屏化了而已嘛。没错，Android沉浸式模式的本质就是全屏化，不过我们今天的内容并不仅限于此，因为还要实现饿了么那样的状态栏效果。那么下面我们就开始来一步步学习吧。<br><img src="http://img.blog.csdn.net/20160820205313182" alt="Android界面介绍"><br>而我们的沉浸式就是,隐藏状态栏,ActionBar,导航栏等,而打造沉浸式模式的用户体验，就是要将这些系统元素全部隐藏，只留下主体内容部分.</p>
<pre><code>&lt;RelativeLayout
xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;&gt;
&lt;ImageView
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:src=&quot;@drawable/bg&quot;
    android:scaleType=&quot;centerCrop&quot; /&gt;
</code></pre><p></p>
<p>在我们程序上运行起来就是这样:<br><img src="http://img.blog.csdn.net/20160820202054200" alt="直接就是一张背景图"><br>但是,在这里的图片,我们并没有将状态栏和导航栏变成透明色和隐藏标题栏;<br>那我们下一步来进行,<strong>注意:</strong>Android的系统在4.1系统之下的的沉浸式状态栏完全不一样,下面我我们就是笔者统计时的Android市场的占有率:<br><img src="http://img2.tuicool.com/7fI773A.jpg!web" alt="Android市场占有率"><br>考虑到4.1版本一下的市场份额小,所以这里只做4.1以上的沉浸式状态栏:</p>
<pre><code>View decorView = getWindow().getDecorView();//当前界面的DecorView
    int option = View.SYSTEM_UI_FLAG_FULLSCREEN;//全屏的意思，也就是会将状态栏隐藏
    decorView.setSystemUiVisibility(option);//来设置系统UI元素的可见性
    ActionBar supportActionBar = getSupportActionBar();
    supportActionBar.hide();
</code></pre><p>根据Android的设计建议，ActionBar是不应该独立于状态栏而单独显示的，因此状态栏如果隐藏了，我们同时也需要调用ActionBar的hide()方法将ActionBar也进行隐藏。<br><img src="http://img.blog.csdn.net/20160820202152211" alt="设置全屏和隐藏ActionBar的结果"></p>
<p>这样看上去就有点沉浸式效果的模样了。<br>虽说这才是正统的沉浸式含义，但有些朋友可能想实现的就是饿了么那样的状态栏效果，而不是直接把整个系统状态栏给隐藏掉，那么又该如何实现呢？<br>其实也很简单，只需要借助另外一种UI Flag就可以了，如下所示：</p>
<pre><code>if(Build.VERSION.SDK_INT &gt;= 21) {//Android5.0以上设置透明状态栏;
        View decorView = getWindow().getDecorView();
        int i = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE;
        decorView.setSystemUiVisibility(i);
        getWindow().setStatusBarColor(Color.TRANSPARENT);
    }
    ActionBar supportActionBar = getSupportActionBar();
    supportActionBar.hide();
</code></pre><p>饿了么这样的效果是只有5.0及以上系统才支持，接下来我们使用了SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN和SYSTEM_UI_FLAG_LAYOUT_STABLE，注意两个Flag必须要结合在一起使用，表示会让应用的主体内容占用系统状态栏的空间，最后再调用Window的setStatusBarColor()方法将状态栏设置成透明色就可以了。<br>现在重新运行一下代码，效果如下图所示。<br><img src="http://img.blog.csdn.net/20160820202256555" alt="透明状态栏实现"><br>可以看到，类似于饿了么的状态栏效果就成功实现了。</p>
<p>######隐藏导航栏<br>现在我们已经成功实现隐藏状态栏的效果了，不过屏幕下方的导航栏还比较刺眼，接下来我们就学习一下如何将导航栏也进行隐藏。<br>其实实现的原理都是一样的，隐藏导航栏也就是使用了不同的UI Flag而已，修改MainActivity中的代码，如下所示：</p>
<pre><code>View decorView = getWindow().getDecorView();
    int option = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
            | View.SYSTEM_UI_FLAG_FULLSCREEN;
    decorView.setSystemUiVisibility(option);
    ActionBar actionBar = getSupportActionBar();
    actionBar.hide();
</code></pre><p>这里我们同时使用了SYSTEM_UI_FLAG_HIDE_NAVIGATION和SYSTEM_UI_FLAG_FULLSCREEN，这样就可以将状态栏和导航栏同时隐藏了。现在重新运行一下程序，效果如图所示。<br><img src="http://img.blog.csdn.net/20160820202400033" alt="隐藏状态栏和导航栏"></p>
<p>除了隐藏导航栏之外，我们同样也可以实现和刚才透明状态栏类似的效果，制作一个透明导航栏：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;<span class="comment">//Android5.0以上设置透明状态栏;</span></div><div class="line">			View decorView = getWindow().getDecorView();</div><div class="line">			<span class="keyword">int</span> i = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE</div><div class="line">					|View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION;</div><div class="line">			decorView.setSystemUiVisibility(i);</div><div class="line">			getWindow().setStatusBarColor(Color.TRANSPARENT);</div><div class="line">			getWindow().setNavigationBarColor(Color.TRANSPARENT);</div><div class="line">		&#125;</div><div class="line">		ActionBar supportActionBar = getSupportActionBar();</div><div class="line">		supportActionBar.hide();</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/09/greendao/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lorensong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lorensong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/09/greendao/" itemprop="url">
                  greendao
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-09T16:01:47+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<ol>
<li>1:1关联<br> 1对1关联,当我们在使用sqlite数据库来实现表的1：1关联时，通常我们会在<strong>主表中定义一个外键去关联副表</strong>，当要查询对应的数据时，首先我们要知道查询数据的外键，然后需要用外键去副表中查询所需要的数据。比如下面这样 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> Long id;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> Long id;</div><div class="line">   <span class="keyword">private</span> Date date;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">long</span> customerId;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>Customer表通过id与Order表关联，查询Order的Customer时需要先知道Order中的customerId然后根据id=customerId值再去数据库中查询该id所对应的Customer对象。然而在greenDao中一个注释就可以搞定，只需要使用@ToOne注释来定义一个关联对象即可。
</code></pre><ol>
<li></li>
</ol>
<hr>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://www.open-open.com/lib/view/open1480319783903.html" target="_blank" rel="external">史上最高效的ORM方案——GreenDao3.0详解</a><br><a href="http://www.jianshu.com/p/d61983df2341" target="_blank" rel="external">史上最高效的ORM方案——GreenDao3.0高级用法</a>  </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/09/customView/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lorensong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lorensong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/09/customView/" itemprop="url">
                  自定义View总览
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-09T11:02:38+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="what"><a href="#what" class="headerlink" title="what?"></a>what?</h3><p>1.View是什么？<br>View是屏幕上的一块矩形区域，它负责用来显示一个区域，并且响应这个区域内的事件。可以说，手机屏幕上的任意一部分看的见得地方都是View，它很常见，比如 TextView 、ImageView 、Button以及LinearLayout、RelativeLayout都是继承子View的。<br>对于Activity来说，我们通过setContentView(view)添加的布局到Activity上，实际上都是添加到了Activity 内部的DecorView上面，这个DecorView，其实就是一个FrameLayout,因此实际上，我们的布局实际上添加到了FrameLayout里面。<br>2.View 是怎么工作的？<br>View的工作流程分为两部分:<br>第一部分 显示在屏幕上的过程;<br>第二部分 响应屏幕上的触摸事件的过程。<br>对于显示在屏幕上的过程：是View 从无到有，经过测量大小(Measure)、确定在屏幕中的位置(Layout)、以及最终绘制在屏幕上(Draw) 这一系列的过程。<br>对于响应屏幕上的触摸事件的过程：则是Touch事件的分发过程(这一部分，在这里先不涉及)。<br>Measure() Layout()方法是final修饰的，无法重写 ，Draw()虽然不是final的，但是也不建议重写该方法。</p>
<h3 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h3><p>回答<br>什么？你说你掌握了自定义View？来来来，回答老衲如下问题：</p>
<p>Google提出View这个概念的目的是什么？<br>View这个概念与Activtiy、Fragment以及Drawable之间是一种什么样的关系？<br>View能够感知Activity的生命周期事件吗？为什么？<br>什么？你说这些问题太抽象？来来来，继续回答如下问题：<br>View的生命周期是什么？<br>当View所在的Activity进入stop状态后，View去哪了？如果我在一个后台线程中持有一个View的引用，我此时能够改变它的状态吗？为什么？<br>View能够与其他的View交叉重叠吗？重叠区域发生的点击事件交给谁去处理呢？可不可以重叠的两个View都处理？<br>View控制一个Drawable的方法途径有哪些？Drawable能不能与View通信？如果能如何通信？<br>假如View所在的ViewGroup中的子View减少了，View因此获得了更大的空间，View如何及时有效地利用这些空间，改变自己的绘制？<br>假如我要在View中动态地注册与解除广播接收器，应该在哪里完成呢？<br>假如我的手机带键盘（自带或者外接），你的自定义View应该如何响应键盘事件。<br>AnimationDrawable作为View的背景，会自动进行动画，View在其中扮演了怎样的角色？<br>假如以上问题你都能准确地回答出来，那么，恭喜你！我觉得你的自定义View已经学到家了，如果有那么几个问题你还搞不清楚，或者不是很确定，那么，请上终南山，闭关三个月，继续参悟自定义View的内在玄机。<br>为什么看了那么多文章，还是无法愉快地与自定义View玩耍？是那些文章不好吗？非也，是你没有掌握学习自定义View的正确姿势（即使你会很多姿势，也木有用，嘎嘎）。你看那些作者，轻轻松松整出一个漂亮的自定义View，你依葫芦画瓢也整出一个，就觉得自己好像也会了，年轻人，你太傲娇了！你想过没有,写这些文章的人是怎么掌握自定义View的？请把这个问题在心中默念三遍。以后读任何技术文章，都问自己这样的问题，相信不久的将来，你也会成为Android大牛的，至少也是小壮牛一头！因为，你已经从学习别人的知识，进入到学习别人的方法的境界了，功力怎能不大增！  </p>
<p>好了，说了这么多，到底怎样才能学好自定义View？其实只需掌握三个问题，就可以轻松搞定它：</p>
<p>问题一：从Android系统设计者的角度，View这个概念究竟是做什么的？<br>问题二：Android系统中那个View类，它有哪些默认功能和行为，能干什么，不能干什么？（知己知彼，才好自定义！）<br>问题三：我要改变这个View的行为，外观，肯定是覆写View类中的方法，但是怎么覆写，覆写哪些方法能够改变哪些行为？<br>以上三个问题，从抽象到具体，我觉得适用于学习任何技术知识，只是每个问题的问法可能因具体技术而有所调整，总体上就是从概念上，从默认实现上，从自己定制上去提问，比如你学习RecyclerView，也可以问以上三个问题，按照这三个问题的顺序一个一个搞懂了，也就完全掌握了这一知识点。 </p>
<p>下面，我们就一个问题一个问题地来解答。</p>
<h4 id="从Android系统设计者的角度，View这个概念究竟是做什么的？"><a href="#从Android系统设计者的角度，View这个概念究竟是做什么的？" class="headerlink" title="从Android系统设计者的角度，View这个概念究竟是做什么的？"></a>从Android系统设计者的角度，View这个概念究竟是做什么的？</h4><p>官方文档是这样描述的:</p>
<blockquote>
<p>This class represents the basic building block for user interface components. A View occupies a rectangular area on the screen and is responsible for drawing and event handling.</p>
</blockquote>
<p>这句话包含三个含义:  </p>
<ul>
<li><p><code>View是用户接口组件的基本构建块</code>。通俗讲，在Android中，一个用户与一个应用的交互，其实就是与这个应用中的许许多多的View的交互，这些View既可以是简单的View，也可以是若干View组合而成的一个复合View。由此我们可以明白，<code>所谓View是基本构件块，原因就在于它是复合View(就是ViewGroup）的基本组成单元</code>。这层含义，就是告诉你，View就是用来与用户交互的，那么很自然地，我们要问，我们用户在哪里与View交互，以及怎样与View交互呢？</p>
</li>
<li><p><code>View在屏幕上占据一个矩形区域</code>。这是说，既然View是用户与应用交互的基本构建块，而用户使用Android设备时，主要是通过一个触摸屏来交互的，相应的，Andorid的设计者们，就让一个View就在屏幕上占据一个矩形区域，用户在这个区域中发生的交互动作（点击、滑动、拖动等），就是与这个View的交互。什么？为什么不让View占据一个圆形区域或者五角星区域呢？当然是为了简单。这就解决了在哪里与View交互的问题。很自然地，我们又想问，View在屏幕上占据一个矩形区域，这个区域的大小、位置怎么确定，它们会不会变化，谁来决定这个变化呢？如果这个变化不是由View自己来决定的，而是其他外界因素决定的，View又要怎样响应这种变化呢？不要急，后面都会有答案。</p>
</li>
<li><p><code>View通过绘制自己与事件处理两种方式与用户交互</code>。这是解决了如何交互的问题。简单讲，View与用户交互就两个办法，一个是改变自己的模样，也就是通过绘制自己与用户交互，比如，当用户点击自己时，就改变自己的背景颜色，以此来告诉用户：本View已经响应你的点击了！第二个方式就是事件处理，比如，当用户点击View时，就完成一定的任务，然后弹出一个Toast，告诉用户该View完成了什么任务，这样，用户也就知道这次交互结果如何。</p>
</li>
</ul>
<p>看到没，这就是官方文档的魅力，短短一句话，胜君读千篇水文。现在我们明白了，设计View，主要是为了让应用能够与用户交互，要想完成交互，这个View就要在屏幕上占据一个矩形区域，然后利用这块屏幕区域与用户交互，交互的方式就两种，绘制自己与事件处理。</p>
<h4 id="Android系统中那个View类，它有哪些默认功能和行为，能干什么，不能干什么？"><a href="#Android系统中那个View类，它有哪些默认功能和行为，能干什么，不能干什么？" class="headerlink" title="Android系统中那个View类，它有哪些默认功能和行为，能干什么，不能干什么？"></a>Android系统中那个View类，它有哪些默认功能和行为，能干什么，不能干什么？</h4><p>解决了第一个问题，我们很可能有更多的疑问，我们想知道：</p>
<p>View是怎样被显示到屏幕上的？</p>
<p>View在屏幕上的位置是怎样决定的？</p>
<p>View所占据的矩形大小是怎样决定的？</p>
<p>屏幕上肯定不止一个View，View之间互相知道对方吗？它们之间能协作吗？</p>
<p>View完成与用户的交互后，能够自动隐藏，在需要交互的时候重新显示在屏幕上吗？</p>
<p>……</p>
<p>现在我们就一点点来讲，学习的同时，最好能够用心体会Google工程师设计时的思路。</p>
<p>这样学习效果最好。</p>
<p>首先，一个用户界面，上面有许多View，既有基本View，也有复合View，把它们组织起来还让它们很好地协作确实是一个难题，Google的解决方案是：首先，一套完整的用户界面用一个Window来表示，Window这个概念和我们在计算机上所说的Window很相似。<code>Window</code>负责管理所有的<code>View</code>们，怎么管理？很简单，借鉴复合View的思路，<code>Window首先加载一个超级复合View</code>，用它来包含住所有的其他View，这个超级复合View就叫做<code>DecorView</code>。但是这个DecorView除了包含我们的用户界面上那些View，还包含了作为一个<code>Window特有的View，叫做titlebar</code>，这个我们就不细说了。</p>
<p>这样，在Window中的View们被组织起来了，一个巨大的ViewGroup（以后，我们不再用复合View这个说法，而代之以<code>ViewGroup</code>，二者是一回事），下面有若干ViewGroup和若干View，每个ViewGroup下面又有若干ViewGroup和若干View，很像数据结构中的树，叶子节点就是基本View。</p>
<p>好了，这些View已经被组织起来了，DecorView已经能够完全控制它们了，同时，DecorView掌握着能够分配给这些View的屏幕区域，包括区域的大小和位置。我们知道，屏幕的大小是有限的，一个Window的DecorView能够控制的屏幕区域更加有限，AndroidN中引入多Window机制后，DecorView能掌控的屏幕区域更加小了，因为屏幕上有多个Window将成为常态。这些有限的区域还要被Window特有的View（titlebar）占去一小部分，剩下的才是留给用户界面上的View们分的，如果你是DecorView,你肯定为难了，如何将这些有限的屏幕区域分给这些View们？分给他们后还得为每个View排好在屏幕上的位置，难上加难。</p>
<p>停一停，想一想，如果是你，你怎么解决这个问题？</p>
<p>首先，不同的View是为了完成特定的交互任务的，比如，Button就是用来点击的，TextView就是用来显示字符的，等等。DecorView知道，不同的View为了完成自己的交互任务所需要的屏幕区域大小是不同的，所以DecorView在确定给每个View分配的屏幕区域大小时，是允许View参与进来，与它一起商量的。但是每个View在屏幕区域中的位置就不能让View自己来决定了，而是由DecorView一手操办，这个比较简单，我们就先来看看DecorView是怎样决定每个View的位置的吧。  </p>
<p>1.确定每个View的位置<br>我们在Activity中，调用了setContentView（View），实际上就是将用户界面的所有的View交给了DecorView中的一个FrameLayout，这个FrameLayou代表着可以分配给用户界面使用的屏幕区域。而用户界面View既可以是一个简单的View，也可以是一个ViewGroup，如果是一个简单的View，比如就是一个TextView，那么这个TextView就会占据整个FrameLayout的屏幕区域，也就是说，此时用户在FrameLayout的屏幕区域内的所有交互都是与这个TextView交互。但是更常见的情况时，我们的用户界面是一个ViewGroup（想想常用的布局五大金刚），里面包含着其他的ViewGroup和View。这个时候，首先这个ViewGroup就会占据FrameLayout所代表的屏幕区域，剩下的任务，就是这个ViewGroup给它内部的小弟们（各种ViewGroup和各种View）分配区域了。至于怎么分，不同的ViewGroup有不同的分法，总体来看，可说是有总有分。所谓总，举例来讲，像vertical的LinearLayout，它按照<br>自己的小弟数量，把自己竖向裁成不同的区域，如下图所示：   </p>
<p>虽然View无法决定自己在ViewGroup中的位置，但是开发者在使用View时，可以向ViewGroup表达自己所用的View要放在哪里，以vertical LinearLayout为例，开发者书写布局文件时，子View在LinearLayout中的出现顺序将决定它们在屏幕上的上下顺序，同时还可以借助layout_margin ,layout_gravity等配置进一步调整子View在分给自己的矩形区域中的位置。到这里，我们可以理解，layout_xxx 之类的配置虽然在书写上与View的属性在一起，<code>但它们并不是View的属性</code>，它们只是使用该View的使用者用来细化调整该View在ViewGroup中的位置的，同时，这些值在<code>Inflate</code>时，是由<code>ViewGroup</code>读取，然后生成一个ViewGroup特定的<code>LayoutParams</code>对象，再把这个对象存入子View中的，这样，ViewGroup在为该子View安排位置时，就可以参考这个<code>LayoutParams</code>中的信息了。进一步思考，我们发现，调用inflate时，除了输入布局文件的id外，一般要求传入<code>parent ViewGroup</code>，传入这个参数的目的，就是为了读取布局文件中的<code>layout</code>配置信息，如果没有传入，这些信息将会丢失，感兴趣的同学可以自己试验验证下，这里就不展开了。不同的<code>ViewGroup</code>拥有不同的<code>LayoutParams</code>内部类，这是因为，它们所允许的子View微微调整自己的位置的方式是不一样的，具体讲就是配置子View时，允许使用的layout_xxx 是不一样的，比如，RelativeLayout就允许layout_toRightOf等配置，其他的ViewGroup没有这些配置。<br>这些确定View的位置的过程，<code>被包装在View 的layout方法中</code>，这样我们也很容易理解，对于基本View而言，这个方法是没有用的，所以都是空的，你可以查看下ImageView、TextView等的源代码，验证下这一点。对于<code>ViewGroup</code>而言，它们会用该方法为自己的子View安排位置。</p>
<p>2、确定View大小</p>
<p>下面，是要确定View的大小了，这是一个开发者、View与ViewGroup三方相互商量的过程。（这里的讲解可能与一般的文章不同，是我个人的理解，一般的文章都不会说是三方商量，而是直接说View与ViewGroup两方商量）</p>
<p><em>第一步</em>，开发者在书写布局文件时，会为一个View写上<br>android:layout_width=”xxx”<br>android:layout_height=”xxx”<br>两个配置，这是开发者向ViewGroup表达的，我这个View需要的大小是多少。”xxx”的取值有三种：<br>具体值，如50dp，很简单，不多讲<br>match_parent ，表示开发者向ViewGroup说，把你所有的屏幕区域都给这个View吧。<br>wrap_parent，表示开发者向ViewGroup说，只要给这个View够他展示自己的空间就行，至于到底给多少，你直接跟View沟通吧，看它怎么说。</p>
<p><em>第二步</em>，ViewGroup收到了开发者对View大小的说明，然后ViewGroup会综合考虑自己的空间大小以及开发者的请求，然后生成两个<code>MeasureSpec对象</code>（width与height）传给View，这两个对象是ViewGroup向子View提出的要求，就相当于告诉子View：“我已经与你的使用者（开发者）商量过了，现在把我们商量确定的结果告诉你，你的宽度不能违反width MeasureSpec对象的要求，你的高度不能违反height MeasureSpec对象的要求，现在，你赶紧根据这个要求确定下自己要多大空间，只许少，不许多哦。”</p>
<p>然后，这两个对象将会传到子View的protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec)方法中。子View能怎么办呢？它肯定是要先看看ViewGroup的要求是什么吧，于是，它从传入的两个对象中解译出如下信息：</p>
<pre><code>`java
int widthMode = MeasureSpec.getMode(widthMeasureSpec);
int widthSize =  MeasureSpec.getSize(widthMeasureSpec);
int heightMode = MeasureSpec.getMode(heightMeasureSpec);
int heightSize =  MeasureSpec.getSize(heightMeasureSpec);
`
</code></pre><p>Mode与Size一起，准确表达出了ViewGroup的要求。下面我们举例说明，假设Size是100dp，<br>Mode的取值有三种，它们代表了ViewGroup的总体态度：<br>1- EXACTLY 表示，ViewGroup对View说，你只能用100dp，原因是多样的，可能是你的使用者说要你完全占据我的空间，而我只有100dp。也可能这是你的使用者的要求，他需要你占这么大的空间，而我恰好也有这么多的空间，你的使用者让你占这么大的空间，肯定有他自己的考虑，你不能不理不顾，不然你达不到他的要求，他可能就不用你了。<br>2- AT_MOST表示，你最多只能用100dp，这是因为你的使用者说让你占据wrap_content的大小，让我跟你商量，我又不知道你到底要占多大区域，但是我告诉你，我只有100dp，你最多也只能用这么多哈。(这里，可以看出，当使用者在布局文件中要求一个View是wrap_content时，此时，View的大小决定权就交给View自己了，默认的View类中的实现，比较粗暴，就是将此时ViewGroup提供的空间全占据，完全没有真正根据自己的内容来确定大小，为什么这么粗暴？因为View是一个基类，所有的组件都是它的子类，每个子类的content都各不相同，View怎么可能知道content的大小呢，所以，它把wrap_content情况下，自己尺寸大小的决定权下放给了不同的子组件，让它们自己根据自己的内容去决定自己的大小，同样，我们自定义View时，也要考虑这一点)<br>3- UNSPECIFIED表示，你自己看着办，把你最理想的大小告诉我，我考虑考虑。</p>
<h3 id="how"><a href="#how" class="headerlink" title="how?"></a>how?</h3><hr>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://www.jianshu.com/p/d507e3514b65?utm_campaign=haruki&amp;utm_content=note&amp;utm_medium=reader_share&amp;utm_source=qq" target="_blank" rel="external">教你步步为营掌握自定义View</a>  </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/08/customView-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lorensong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lorensong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/08/customView-5/" itemprop="url">
                  自定义View-5之彩虹横向进度条
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-08T12:33:11+08:00">
                2017-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h3><h3 id="how"><a href="#how" class="headerlink" title="how?"></a>how?</h3><p>1.自定义类继承View<br>2.在包名/values文件夹下创建attrs.xml文件,并写上需要的属性<br>3.在自定义类中获取attrs中的属性值<br>4.重写onMeasure();<br>5.重写onDraw();<br>6.在相应的布局文件中使用</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>1.自定义View</p>
<hr>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://blog.csdn.net/lmj623565791/article/details/38339817" target="_blank" rel="external">Android 手把手教您自定义ViewGroup（一）</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/07/customView-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lorensong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lorensong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/07/customView-4/" itemprop="url">
                  自定义View-4
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-07T17:16:59+08:00">
                2017-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h3><h3 id="how"><a href="#how" class="headerlink" title="how?"></a>how?</h3><p>1.自定义类继承View<br>2.在包名/values文件夹中创建attrs.xml文件<br>3.在自定义类中获取相应的属性值<br>4.重写onMeasure();[不需要]<br>5.重写ondraw();<br>6.在相应的布局文件中使用.<br>7.根据手势设置音量大小</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>1.自定义类(省略);<br>2.创建attrs.xml文件<br><em>分析:</em>需要中间图片一张,音量有和无的颜色,音量的宽度,音量的点的个数,音量的间隙大小  </p>
<pre><code>&lt;attr name=&quot;ValumefirstColor&quot; format=&quot;color&quot;/&gt;
&lt;attr name=&quot;ValumeSecondColor&quot; format=&quot;color&quot;/&gt;
&lt;attr name=&quot;ValumeCircleWidth&quot; format=&quot;dimension&quot;/&gt;
&lt;attr name=&quot;ValumeDotCount&quot; format=&quot;integer&quot;/&gt;
&lt;attr name=&quot;ValumeSplitSize&quot; format=&quot;integer&quot;/&gt;
&lt;attr name=&quot;Valumebg&quot; format=&quot;reference&quot;/&gt;

&lt;declare-styleable name=&quot;CustomValumeView&quot;&gt;
    &lt;attr name=&quot;ValumefirstColor&quot;/&gt;
    &lt;attr name=&quot;ValumeSecondColor&quot;/&gt;
    &lt;attr name=&quot;ValumeCircleWidth&quot;/&gt;
    &lt;attr name=&quot;ValumeDotCount&quot;/&gt;
    &lt;attr name=&quot;ValumeSplitSize&quot;/&gt;
    &lt;attr name=&quot;Valumebg&quot;/&gt;
&lt;/declare-styleable&gt;
</code></pre><p>3.自定义类获取属性值</p>
<pre><code>private void initView(Context context, AttributeSet attrs, int defStyleAttr) {
    TypedArray typedArray = context.getTheme()
            .obtainStyledAttributes(attrs, R.styleable.CustomValumeView, defStyleAttr, 0);
    int indexCount = typedArray.getIndexCount();
    for (int i = 0; i &lt; indexCount; i++) {
        int attr = typedArray.getIndex(i);
        switch (attr) {

            case R.styleable.CustomValumeView_ValumefirstColor:
                mFirstColor = typedArray.getColor(attr, Color.BLACK);
                break;
            case R.styleable.CustomValumeView_ValumeSecondColor:
                mSecondColor = typedArray.getColor(attr, Color.BLUE);
                break;
            case R.styleable.CustomValumeView_Valumebg:
                mImage = BitmapFactory.decodeResource(getResources(), typedArray.getResourceId(attr, 0));
                break;
            case R.styleable.CustomValumeView_ValumeCircleWidth:
                mCircleWidth = typedArray.getDimensionPixelSize(attr, (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_PX, 16, getResources().getDisplayMetrics()));
                break;
            case R.styleable.CustomValumeView_ValumeDotCount:
                mDotCount = typedArray.getInt(attr, 20);//默认值
                break;
            case R.styleable.CustomValumeView_ValumeSplitSize:
                mSplitSize = typedArray.getInt(attr, 20);
                break;
            default:
                break;
        }

    }
    typedArray.recycle();
    mPaint = new Paint();
    mRectF = new RectF();
}
</code></pre><p>5.重写onDraw();</p>
<pre><code>@Override
protected void onDraw(Canvas canvas) {
    mPaint.setAntiAlias(true);//消除锯齿
    mPaint.setStrokeWidth(mCircleWidth);//设置音量宽度
    mPaint.setStrokeCap(Paint.Cap.ROUND);//设置线段断开的地方是圆头
    mPaint.setStyle(Paint.Style.STROKE);//空心
    int center = getWidth() / 2;//获取圆心坐标
    int radius = center - mCircleWidth / 2;//半径
    drawValumePiece(canvas, center, radius);
    drawImage(canvas, radius);
}
//画出内部的音量图片
private void drawImage(Canvas canvas, int radius) {
    //计算内切正方形的位置
    int relRadius = radius - mCircleWidth / 2;//获取内圆半径
    //内切正方形的距离顶部 = mCircleWidth + relRadius - √2 / 2
    mRectF.left = (int) ((relRadius - Math.sqrt(2) * 1.0f / 2 * relRadius) + mCircleWidth);
    //内切正方形的距离左边 = mCircleWidth + relRadius - √2 / 2
    mRectF.top = (int) ((relRadius - Math.sqrt(2) * 1.0f / 2 * relRadius) + mCircleWidth);

    mRectF.bottom = (int) (mRectF.left + Math.sqrt(2) * relRadius);
    mRectF.right = (int) (mRectF.left + Math.sqrt(2) * relRadius);

    //设置图片到中心,如果图片宽度太小,就设置到中间
    if (mImage.getWidth() &lt; Math.sqrt(2) * relRadius) {
        mRectF.left = (int) (mRectF.left + Math.sqrt(2) * relRadius * 1.0f / 2 - mImage.getWidth() * 1.0f / 2);
        mRectF.top = (int) (mRectF.top + Math.sqrt(2) * relRadius * 1.0f / 2 - mImage.getHeight() * 1.0f / 2);
        mRectF.right = (mRectF.left + mImage.getWidth());
        mRectF.bottom = (mRectF.top + mImage.getHeight());
    }
    canvas.drawBitmap(mImage, null, mRectF, mPaint);
}
//主要用来画旁边小块
private void drawValumePiece(Canvas canvas, int center, int radius) {
    //根据需要画出小快递的个数和间隙算出每个小块所应当占用的比例*360;
    float itemSize = (360 * 1.0f - mDotCount * mSplitSize) / mDotCount;
    //定义圆环的界限的矩形,外接矩形
    RectF oval = new RectF(center - radius, center - radius, center + radius, center + radius);
    mPaint.setColor(mFirstColor);//设置圆环颜色
    for (int i = 0; i &lt; mDotCount; i++) {
        canvas.drawArc(oval, i * (itemSize + mSplitSize), itemSize, false, mPaint);
    }
    mPaint.setColor(mSecondColor);
    for (int i = 0; i &lt; mCurrentCount; i++) {
        canvas.drawArc(oval, i * (itemSize + mSplitSize), itemSize, false, mPaint);
    }
}
</code></pre><p>6.在布局文件中使用</p>
<pre><code>&lt;LinearLayout
xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:custom=&quot;http://schemas.android.com/apk/res-auto&quot;
android:id=&quot;@+id/activity_main&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:orientation=&quot;vertical&quot;&gt;
&lt;com.loren.customview.view.CustomValumeView
    android:layout_width=&quot;100dp&quot;
    android:layout_height=&quot;100dp&quot;
    custom:ValumefirstColor=&quot;#4400ff&quot;
    custom:ValumeSecondColor=&quot;#992255&quot;
    custom:ValumeCircleWidth=&quot;3dp&quot;
    custom:ValumeDotCount=&quot;50&quot;
    custom:ValumeSplitSize=&quot;5&quot;
    custom:Valumebg=&quot;@mipmap/ic_launcher&quot;/&gt;
&lt;com.loren.customview.view.CustomValumeView
    android:layout_width=&quot;200dp&quot;
    android:layout_height=&quot;200dp&quot;
    custom:ValumefirstColor=&quot;#4400ff&quot;
    custom:ValumeSecondColor=&quot;#992255&quot;
    custom:ValumeCircleWidth=&quot;3dp&quot;
    android:layout_gravity=&quot;center&quot;
    custom:ValumeDotCount=&quot;30&quot;
    custom:ValumeSplitSize=&quot;5&quot;
    custom:Valumebg=&quot;@mipmap/p1&quot;/&gt;
&lt;/LinearLayout&gt;
</code></pre><p>7.添加手势监听<br>当我们手机上下移动的时候,会指定增加或减少</p>
<pre><code>//点击添加
public void up() {
    if (mCurrentCount &lt; mDotCount) {
        mCurrentCount++;
    }

    postInvalidate();
}

public void down() {
    if (mCurrentCount &gt; 0) {
        mCurrentCount--;
    }
    postInvalidate();
}

private int mDownY;

@Override
public boolean onTouchEvent(MotionEvent event) {
    switch (event.getAction()) {

        case MotionEvent.ACTION_DOWN:
            mDownY = (int) event.getY();
            mLastMoveY = mDownY;
            break;
        case MotionEvent.ACTION_MOVE:
            mCurrentMoveY = (int) event.getY();
            mDifY = mCurrentMoveY - mLastMoveY;
            //用5做判断是为了减小方块着色的速度
            if(mDifY &gt; 5) {
                up();
            }else if(mDifY &lt; -5) {
                down();
            }
            mLastMoveY = mCurrentMoveY;
            break;

        default:
            break;
    }

    return true;
}
</code></pre><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><h3 id="所有代码"><a href="#所有代码" class="headerlink" title="所有代码"></a>所有代码</h3><pre><code>public class CustomValumeView extends View {

private Paint  mPaint;
private int    mFirstColor;
private int    mSecondColor;
private Bitmap mImage;
private int    mCircleWidth;
private int    mDotCount;
private int    mSplitSize;//每个方块之间的间隙
private RectF  mRectF;
private int    mCurrentCount;//当前的数量;
private int    mCurrentMoveY;
private int    mDifY;
private int mLastMoveY;

public CustomValumeView(Context context) {
    this(context, null);
}

public CustomValumeView(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public CustomValumeView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    initView(context, attrs, defStyleAttr);
}

private void initView(Context context, AttributeSet attrs, int defStyleAttr) {
    TypedArray typedArray = context.getTheme()
            .obtainStyledAttributes(attrs, R.styleable.CustomValumeView, defStyleAttr, 0);
    int indexCount = typedArray.getIndexCount();
    for (int i = 0; i &lt; indexCount; i++) {
        int attr = typedArray.getIndex(i);
        switch (attr) {

            case R.styleable.CustomValumeView_ValumefirstColor:
                mFirstColor = typedArray.getColor(attr, Color.BLACK);
                break;
            case R.styleable.CustomValumeView_ValumeSecondColor:
                mSecondColor = typedArray.getColor(attr, Color.BLUE);
                break;
            case R.styleable.CustomValumeView_Valumebg:
                mImage = BitmapFactory.decodeResource(getResources(), typedArray.getResourceId(attr, 0));
                break;
            case R.styleable.CustomValumeView_ValumeCircleWidth:
                mCircleWidth = typedArray.getDimensionPixelSize(attr, (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_PX, 16, getResources().getDisplayMetrics()));
                break;
            case R.styleable.CustomValumeView_ValumeDotCount:
                mDotCount = typedArray.getInt(attr, 20);//默认值
                break;
            case R.styleable.CustomValumeView_ValumeSplitSize:
                mSplitSize = typedArray.getInt(attr, 20);
                break;
            default:
                break;
        }

    }
    typedArray.recycle();
    mPaint = new Paint();
    mRectF = new RectF();
}

@Override
protected void onDraw(Canvas canvas) {
    mPaint.setAntiAlias(true);//消除锯齿
    mPaint.setStrokeWidth(mCircleWidth);//设置音量宽度
    mPaint.setStrokeCap(Paint.Cap.ROUND);//设置线段断开的地方是圆头
    mPaint.setStyle(Paint.Style.STROKE);//空心
    int center = getWidth() / 2;//获取圆心坐标
    int radius = center - mCircleWidth / 2;//半径
    drawValumePiece(canvas, center, radius);
    drawImage(canvas, radius);
}
//画出内部的音量图片
private void drawImage(Canvas canvas, int radius) {
    //计算内切正方形的位置
    int relRadius = radius - mCircleWidth / 2;//获取内圆半径
    //内切正方形的距离顶部 = mCircleWidth + relRadius - √2 / 2
    mRectF.left = (int) ((relRadius - Math.sqrt(2) * 1.0f / 2 * relRadius) + mCircleWidth);
    //内切正方形的距离左边 = mCircleWidth + relRadius - √2 / 2
    mRectF.top = (int) ((relRadius - Math.sqrt(2) * 1.0f / 2 * relRadius) + mCircleWidth);

    mRectF.bottom = (int) (mRectF.left + Math.sqrt(2) * relRadius);
    mRectF.right = (int) (mRectF.left + Math.sqrt(2) * relRadius);

    //设置图片到中心,如果图片宽度太小,就设置到中间
    if (mImage.getWidth() &lt; Math.sqrt(2) * relRadius) {
        mRectF.left = (int) (mRectF.left + Math.sqrt(2) * relRadius * 1.0f / 2 - mImage.getWidth() * 1.0f / 2);
        mRectF.top = (int) (mRectF.top + Math.sqrt(2) * relRadius * 1.0f / 2 - mImage.getHeight() * 1.0f / 2);
        mRectF.right = (mRectF.left + mImage.getWidth());
        mRectF.bottom = (mRectF.top + mImage.getHeight());
    }
    canvas.drawBitmap(mImage, null, mRectF, mPaint);
}
//主要用来画旁边小块
private void drawValumePiece(Canvas canvas, int center, int radius) {
    //根据需要画出小快递的个数和间隙算出每个小块所应当占用的比例*360;
    float itemSize = (360 * 1.0f - mDotCount * mSplitSize) / mDotCount;
    //定义圆环的界限的矩形,外接矩形
    RectF oval = new RectF(center - radius, center - radius, center + radius, center + radius);
    mPaint.setColor(mFirstColor);//设置圆环颜色
    for (int i = 0; i &lt; mDotCount; i++) {
        canvas.drawArc(oval, i * (itemSize + mSplitSize), itemSize, false, mPaint);
    }
    mPaint.setColor(mSecondColor);
    for (int i = 0; i &lt; mCurrentCount; i++) {
        canvas.drawArc(oval, i * (itemSize + mSplitSize), itemSize, false, mPaint);
    }
}

//点击添加
public void up() {
    if (mCurrentCount &lt; mDotCount) {
        mCurrentCount++;
    }

    postInvalidate();
}

public void down() {
    if (mCurrentCount &gt; 0) {
        mCurrentCount--;
    }
    postInvalidate();
}

private int mDownY;

@Override
public boolean onTouchEvent(MotionEvent event) {
    switch (event.getAction()) {

        case MotionEvent.ACTION_DOWN:
            mDownY = (int) event.getY();
            mLastMoveY = mDownY;
            break;
        case MotionEvent.ACTION_MOVE:
            mCurrentMoveY = (int) event.getY();
            mDifY = mCurrentMoveY - mLastMoveY;
            //用5做判断是为了减小方块着色的速度
            if(mDifY &gt; 5) {
                up();
            }else if(mDifY &lt; -5) {
                down();
            }
            mLastMoveY = mCurrentMoveY;
            break;

        default:
            break;
    }

    return true;
}
}
</code></pre><hr>
<h3 id="参看文档"><a href="#参看文档" class="headerlink" title="参看文档"></a>参看文档</h3><p><a href="http://blog.csdn.net/lmj623565791/article/details/24529807" target="_blank" rel="external">Android 自定义View (四) 视频音量调控</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/07/customView-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lorensong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lorensong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/07/customView-3/" itemprop="url">
                  自定义View-3
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-07T12:08:39+08:00">
                2017-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h3><p><img width="" height="" align="center" src="customView-3\why_realize_result_2017-3-7.png" alt="why_realize_result_2017-3-7"></p>
<h3 id="how"><a href="#how" class="headerlink" title="how?"></a>how?</h3><p><em>老司机-老套路-老路线:</em><br>1.自定义一个类继承View<br>2.在包名/values文件夹中创建attrs.xml文件<br>3.在自定义的类中获取attrs中的属性<br>4.重写onMeasure(); <em>不需要</em><br>5.重写ondraw();<br>6.在相应的布局文件是使用View;  </p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>1.自定义View类:<br>省略<br>2.创建attrs文件:</p>
<pre><code><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"firstColor"</span> <span class="attr">format</span>=<span class="string">"color"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"secondColor"</span> <span class="attr">format</span>=<span class="string">"color"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"circleWidth"</span> <span class="attr">format</span>=<span class="string">"dimension"</span>/&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"speed"</span> <span class="attr">format</span>=<span class="string">"integer"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">"CustomProgressBar"</span>&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"firstColor"</span>/&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"secondColor"</span>/&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"circleWidth"</span>/&gt;</span></div><div class="line">       <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">"speed"</span>/&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></div></pre></td></tr></table></figure>
</code></pre><p>3.获取attrs文件的属性</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</div><div class="line">	TypedArray typedArray = context.getTheme()</div><div class="line">			.obtainStyledAttributes(attrs, R.styleable.CustomProgressBar, defStyleAttr, <span class="number">0</span>);</div><div class="line">	<span class="keyword">int</span> indexCount = typedArray.getIndexCount();</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indexCount; i++) &#123;</div><div class="line">		<span class="keyword">int</span> attr = typedArray.getIndex(i);</div><div class="line">		<span class="keyword">switch</span> (attr) &#123;</div><div class="line"></div><div class="line">			<span class="keyword">case</span> R.styleable.CustomProgressBar_firstColor:</div><div class="line">				mFirstColor = typedArray.getColor(attr, Color.BLACK);</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			<span class="keyword">case</span> R.styleable.CustomProgressBar_secondColor:</div><div class="line">				mSecondColor = typedArray.getColor(attr, Color.BLUE);</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			<span class="keyword">case</span> R.styleable.CustomProgressBar_circleWidth:</div><div class="line">				mCircleWidth = typedArray.getDimensionPixelSize(attr, (<span class="keyword">int</span>) TypedValue.applyDimension</div><div class="line">					(TypedValue.COMPLEX_UNIT_PX, <span class="number">20</span>, getResources().getDisplayMetrics()));</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			<span class="keyword">case</span> R.styleable.CustomProgressBar_speed:</div><div class="line">				mSpeed = typedArray.getInt(attr, <span class="number">20</span>);</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			<span class="keyword">default</span>:</div><div class="line">				<span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误"</span>);</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	typedArray.recycle();</div><div class="line">	mPaint = <span class="keyword">new</span> Paint();</div><div class="line">	<span class="comment">//绘图线程</span></div><div class="line">	<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">				mProgress++;</div><div class="line">				<span class="keyword">if</span>(mProgress == <span class="number">360</span>) &#123;</div><div class="line">					<span class="comment">//在进行到360度的时候要改变颜色</span></div><div class="line">					mProgress = <span class="number">0</span>;</div><div class="line">					<span class="keyword">if</span>(!isNext) &#123;</div><div class="line">						isNext = <span class="keyword">true</span>;</div><div class="line">					&#125;<span class="keyword">else</span> &#123;</div><div class="line">						isNext = <span class="keyword">false</span>;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				postInvalidate();</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					<span class="comment">//延迟</span></div><div class="line">					Thread.sleep(mSpeed);</div><div class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>5.重写onDraw();</p>
<pre><code>@Override
protected void onDraw(Canvas canvas) {
    int center = getWidth() / 2;//获取圆心坐标
    int radius = center - mCircleWidth / 2;//获取半径
    mPaint.setStrokeWidth(mCircleWidth);//设置线框宽度
    mPaint.setAntiAlias(true);//消除锯齿
    mPaint.setStyle(Paint.Style.STROKE);//设置为空心
    //定义外接圆,也就是限定整个圆的区域
    RectF oval = new RectF(center - radius, center - radius, center + radius, center + radius);
    if(!isNext) {
        mPaint.setColor(mFirstColor);//设置底部圆环颜色
        canvas.drawCircle(center, center, radius, mPaint);//画出底部圆环
        mPaint.setColor(mSecondColor);
        /*
        oval：圆弧所在的椭圆对象 startAngle：圆弧的起始角度 sweepAngle：圆弧的角度 
        useCenter：是否显示半径连线，true表示显示圆弧与圆心的半径连线，false表示不显示。
        paint：绘制时所使用的画笔。
         */
        canvas.drawArc(oval, -90, mProgress, false, mPaint);//根据进度画圆弧
    }else {
        mPaint.setColor(mSecondColor);
        canvas.drawCircle(center, center, radius, mPaint);
        mPaint.setColor(mFirstColor);
        canvas.drawArc(oval, -90, mProgress, false, mPaint);
    }
}
</code></pre><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre><code>public class CustomProgressBar extends View {

private Paint mPaint;
private int   mFirstColor;//开始颜色
private int   mSecondColor;//第二次的颜色
private int   mCircleWidth;//圆环的厚度
private int   mSpeed;//滚动的速度
private int   mProgress;//当前的角度
private boolean isNext = false;//是否要切换下一个

public CustomProgressBar(Context context) {
    this(context, null);
}

public CustomProgressBar(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public CustomProgressBar(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    initView(context, attrs, defStyleAttr);

}

private void initView(Context context, AttributeSet attrs, int defStyleAttr) {
    TypedArray typedArray = context.getTheme()
            .obtainStyledAttributes(attrs, R.styleable.CustomProgressBar, defStyleAttr, 0);
    int indexCount = typedArray.getIndexCount();
    for (int i = 0; i &lt; indexCount; i++) {
        int attr = typedArray.getIndex(i);
        switch (attr) {

            case R.styleable.CustomProgressBar_firstColor:
                mFirstColor = typedArray.getColor(attr, Color.BLACK);
                break;
            case R.styleable.CustomProgressBar_secondColor:
                mSecondColor = typedArray.getColor(attr, Color.BLUE);
                break;
            case R.styleable.CustomProgressBar_circleWidth:
                mCircleWidth = typedArray.getDimensionPixelSize(attr, (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_PX, 20, getResources().getDisplayMetrics()));
                break;
            case R.styleable.CustomProgressBar_speed:
                mSpeed = typedArray.getInt(attr, 20);
                break;
            default:
                new IllegalArgumentException(&quot;参数错误&quot;);
                break;
        }

    }
    typedArray.recycle();
    mPaint = new Paint();
    //绘图线程
    new Thread(new Runnable() {
        @Override
        public void run() {
            while (true) {
                mProgress++;
                if (mProgress == 360) {
                    //在进行到360度的时候要改变颜色
                    mProgress = 0;
                    if (!isNext) {
                        isNext = true;
                    } else {
                        isNext = false;
                    }
                }
                postInvalidate();
                try {
                    //延迟
                    Thread.sleep(mSpeed);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
        }
    }).start();
}

@Override
protected void onDraw(Canvas canvas) {
    int center = getWidth() / 2;//获取圆心坐标
    int radius = center - mCircleWidth / 2;//获取半径
    mPaint.setStrokeWidth(mCircleWidth);//设置线框宽度
    mPaint.setAntiAlias(true);//消除锯齿
    mPaint.setStyle(Paint.Style.STROKE);//设置为空心
    //定义外接圆,也就是限定整个圆的区域
    RectF oval = new RectF(center - radius, center - radius, center + radius, center + radius);
    if (!isNext) {
        mPaint.setColor(mFirstColor);//设置底部圆环颜色
        canvas.drawCircle(center, center, radius, mPaint);//画出底部圆环
        mPaint.setColor(mSecondColor);
        /*
        oval：圆弧所在的椭圆对象 startAngle：圆弧的起始角度 sweepAngle：圆弧的角度
        useCenter：是否显示半径连线，true表示显示圆弧与圆心的半径连线，false表示不显示。
        paint：绘制时所使用的画笔。
         */
        canvas.drawArc(oval, -90, mProgress, false, mPaint);//根据进度画圆弧
    } else {
        mPaint.setColor(mSecondColor);
        canvas.drawCircle(center, center, radius, mPaint);
        mPaint.setColor(mFirstColor);
        canvas.drawArc(oval, -90, mProgress, false, mPaint);
    }
}
}
</code></pre><hr>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://blog.csdn.net/lmj623565791/article/details/24500107" target="_blank" rel="external">Android 自定义View (三) 圆环交替 等待效果</a><br><a href="http://book.51cto.com/art/201204/328276.htm" target="_blank" rel="external">drawArc方法：绘制圆弧</a>  </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/06/customView-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lorensong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lorensong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/06/customView-2/" itemprop="url">
                  自定义View_2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-06T17:54:44+08:00">
                2017-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h3><p>效果图:<br><img width="" height="50%" align="center" src="\customView-2\customView_result_2017-3-6.png" alt="customView_result_2017-3-6"></p>
<h3 id="how"><a href="#how" class="headerlink" title="how?"></a>how?</h3><p>1.写一个自定义类继承View;<br>2.在values文件夹中创建attrs.xml文件(这是自定义的属性)<br>3.在自定义类的构造中获取到attrs的属性值;<br>4.重写onMeasure();<br>5.重写onDraw();<br>6.在相应的布局文件中使用自定义view;</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ol>
<li>自定义CustomImageView类,并重写构造方法;</li>
<li><p>创建attrs.xml文件</p>
<p>其中<code>CustomTitleView</code>是自定义<code>TextView</code>的代码,可以见笔者 自定义View-1,笔者只是将两种自定义写在一起了.<br>而<code>CustomImageView</code>是本次需要的内容</p>
  <resources><br>  <attr name="titleText" format="string"><br>  <attr name="titleColor" format="color"><br>  <attr name="titleSize" format="dimension"><br><br>  <attr name="titleImageText" format="string"><br>  <attr name="titleImageTextSize" format="dimension"><br>  <attr name="titleImageTextColor" format="color"><br>  <attr name="image" format="reference"><br>  <attr name="imageScaleType"><br>  <enum name="fillXY" value="0"><br>  <enum name="center" value="1"><br>  </enum></enum></attr><br>  <declare-styleable name="CustomTitleView"><br>  <attr name="titleText"><br>  <attr name="titleColor"><br>  <attr name="titleSize"><br>  </attr></attr></attr></declare-styleable><br><br>  <declare-styleable name="CustomImageView"><br>  <attr name="titleImageText"><br>  <attr name="titleImageTextSize"><br>  <attr name="titleImageTextColor"><br>  <attr name="image"><br>  <attr name="imageScaleType"><br>  </attr></attr></attr></attr></attr></declare-styleable><br>  </attr></attr></attr></attr></attr></attr></attr></resources></li>
<li><p>在自定义类中获取属性值</p>
<p>private void initView(AttributeSet attrs, int defStyleAttr) {<br>  TypedArray typedArray = mContext.getTheme()</p>
<pre><code>.obtainStyledAttributes(attrs, R.styleable.CustomImageView, defStyleAttr, 0);
</code></pre><p>  int indexCount = typedArray.getIndexCount();</p>
<p>  for (int i = 0; i &lt; indexCount; i++) {</p>
<pre><code>int attr = typedArray.getIndex(i);
switch (attr) {

    case R.styleable.CustomImageView_image:
        mBitmap = BitmapFactory.decodeResource(getResources(), typedArray.getResourceId(attr, 0));
        break;
    case R.styleable.CustomImageView_imageScaleType:
        mScaleType = typedArray.getInt(attr, 0);
        break;

    case R.styleable.CustomImageView_titleImageText:
        mTitleImageText = typedArray.getString(attr);

        break;
    case R.styleable.CustomImageView_titleImageTextColor:
        mTextColor = typedArray.getColor(attr, Color.BLACK);

        break;
    case R.styleable.CustomImageView_titleImageTextSize:
        mTitleSize = typedArray.getDimensionPixelSize(attr, (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, 16, getResources().getDisplayMetrics()));

        break;
}
</code></pre><p>  }<br>  typedArray.recycle();<br>  mPaint = new Paint();<br>  mRect = new Rect();<br>  mTextBound = new Rect();<br>  mPaint.setTextSize(mTitleSize);<br>  //计算文字所在矩形,获取宽高值<br>  mPaint.getTextBounds(mTitleImageText, 0, mTitleImageText.length(), mTextBound);<br>  }   </p>
</li>
</ol>
<p>4.重写onMeasure()方法</p>
<pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    //宽度
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    int widthSize = MeasureSpec.getSize(widthMeasureSpec);

    if (widthMode == MeasureSpec.EXACTLY) {
        mWidth = widthSize;
    } else {
        //测量出图片和文字的宽度,看整个view的宽度由谁决定

        //图片宽度
        int desiredByImg = getPaddingLeft() + getPaddingRight() + mBitmap.getWidth();
        //字体宽度
        int desirdeByText = getPaddingLeft() + getPaddingRight() + mTextBound.width();
        //判断宽度模式是否warp_content
        if (widthMode == MeasureSpec.AT_MOST) {
            int desiredWidth = Math.max(desiredByImg, desirdeByText);
            //因为是wrap_content,默认值是宽度整个父类的view的宽度,所以这里需要取最小值,整个布局仅仅包裹我们需要的内容
            mWidth = Math.min(desiredWidth, widthSize);
        }
    }
    //高度
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    if (heightMode == MeasureSpec.EXACTLY) {
        mHeight = heightSize;
    } else {
        int desire = getPaddingTop() + getPaddingBottom() + mBitmap.getHeight() + mTextBound.height();
        if (heightMode == MeasureSpec.AT_MOST) {
            mHeight = Math.min(desire, heightSize);
        }
    }
    setMeasuredDimension(mWidth, mHeight);

}
</code></pre><p>5.重写ondraw()方法</p>
<pre><code>@Override
protected void onDraw(Canvas canvas) {
    //设置边框
    mPaint.setStrokeWidth(4);
    mPaint.setStyle(Paint.Style.STROKE);
    mPaint.setColor(Color.CYAN);
    canvas.drawRect(0, 0, getMeasuredWidth(), getMeasuredHeight(), mPaint);

    mRect.left = getPaddingLeft();
    mRect.right = mWidth - getPaddingRight();
    mRect.top = getPaddingTop();
    mRect.bottom = mHeight - getPaddingBottom();

    mPaint.setColor(mTextColor);
    mPaint.setStyle(Paint.Style.FILL);

    //当前设置的宽度小于字体需要的宽度,将字体大小设置为指定的省略号...;
    if (mTextBound.width() &gt; mWidth) {
        TextPaint textPaint = new TextPaint(mPaint);

        //TextUtils.ellipsize()截取指定长度字符串
        String s = TextUtils.ellipsize(mTitleImageText, textPaint, mWidth - getPaddingLeft() - getPaddingRight(), TextUtils.TruncateAt.END)
                .toString();
        canvas.drawText(s, getPaddingLeft(), mHeight - getPaddingRight(), mPaint);
    } else {
        //正常情况,将字体居中
        canvas.drawText(mTitleImageText, mWidth / 2 - mTextBound.width() * 1.0f / 2, mHeight - getPaddingBottom() / 2, mPaint);
    }
    //取消文字使用的块,用于设置图片
    //如果不减掉的话使用fillXY模式时，会把下面的文字覆盖
    mRect.bottom = mRect.bottom -  mTextBound.height();

    if (mScaleType == IMAGE_SCALE_FITXY) {
        canvas.drawBitmap(mBitmap, null, mRect, mPaint);
    } else {
        //如果图片的缩放是居中类型的,需要将图片设置为居中
        //计算居中的矩形范围;
        mRect.left = mWidth / 2 - mBitmap.getWidth() / 2;
        mRect.right = mWidth / 2 + mBitmap.getWidth() / 2;
        mRect.top = (mHeight - mTextBound.height()) / 2 - mBitmap.getHeight() / 2;
        mRect.bottom = (mHeight - mTextBound.height()) / 2 + mBitmap.getHeight() / 2;
        canvas.drawBitmap(mBitmap, null, mRect, mPaint);
    }
}
</code></pre><p>6.使用</p>
<pre><code>&lt;com.loren.customview.view.CustomImageView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;150dp&quot;
    custom:image=&quot;@mipmap/ic_launcher&quot;
    custom:imageScaleType=&quot;center&quot;
    custom:titleImageText=&quot;p1图片p1图片p1图片p1图片p1图片p1图片&quot;
    custom:titleImageTextSize=&quot;16sp&quot;
    custom:titleImageTextColor=&quot;#ff0000&quot;
    android:id=&quot;@+id/customImageView&quot;/&gt;

&lt;com.loren.customview.view.CustomImageView
    android:layout_width=&quot;100dp&quot;
    android:layout_height=&quot;50dp&quot;
    custom:image=&quot;@mipmap/ic_launcher&quot;
    custom:imageScaleType=&quot;center&quot;
    custom:titleImageText=&quot;p2图片p2图片p2图片p2图片p2图片p2图片&quot;
    custom:titleImageTextSize=&quot;18sp&quot;
    custom:titleImageTextColor=&quot;#ff00ff&quot;
    /&gt;
&lt;com.loren.customview.view.CustomImageView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    custom:image=&quot;@mipmap/p3&quot;
    custom:imageScaleType=&quot;fillXY&quot;
    custom:titleImageText=&quot;p3图片&quot;
    custom:titleImageTextSize=&quot;12sp&quot;
    custom:titleImageTextColor=&quot;#ff2299&quot;
    /&gt;
</code></pre><p><em>效果图见开始处</em></p>
<h4 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h4><p>计算文字在控件中间的两种方式：  </p>
<ul>
<li><p>方法2是绝对准确，推荐使用。</p>
</li>
<li><p>方法1有时候会测量不准确，高度不能居中显示<br>1.宽 = （控件宽 - 文字宽）/2<br>  高 = (控件高 + 文字稿) /2<br>2.宽 = （控件宽 - 文字宽）/2<br>  高 = （控件高 - （文字上边界 + 文字下边界）/2   </p>
</li>
</ul>
<hr>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://blog.csdn.net/lmj623565791/article/details/24300125" target="_blank" rel="external">Android 自定义View(二)进阶</a><br><a href="http://blog.csdn.net/qin9r3y/article/details/8607014" target="_blank" rel="external">Android drawText获取text宽度的三种方式</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/03/customView-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lorensong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lorensong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/03/customView-1/" itemprop="url">
                  自定义View-1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-03T18:11:53+08:00">
                2017-03-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h3><p><img width="" height="50%" align="center" src="\customView-1\custom_view_result_2017-3-6.png" alt="custom_view_result_2017-3-6"></p>
<p><strong>效果</strong>:点击文字,改变数字</p>
<h3 id="how"><a href="#how" class="headerlink" title="how?"></a>how?</h3><ol>
<li>自定义类继承View;</li>
<li>自定义View的属性;</li>
<li>在View的构造方法中获得我们自定义的属性;</li>
<li>重写onMeasure();</li>
<li>重写ondraw();<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="自定义类继承View"><a href="#自定义类继承View" class="headerlink" title="自定义类继承View"></a>自定义类继承View</h4>写一个类继承View,并重写构造方法.  <h4 id="自定义View的属性"><a href="#自定义View的属性" class="headerlink" title="自定义View的属性"></a>自定义View的属性</h4></li>
</ol>
<p>1、自定义View的属性，首先在应用包中/res/values/  下建立一个attrs.xml ， 在里面定义我们的属性和声明我们的整个样式。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;resources&gt;    
&lt;attr name=&quot;titleText&quot; format=&quot;string&quot; /&gt;  
&lt;attr name=&quot;titleTextColor&quot; format=&quot;color&quot; /&gt;  
&lt;attr name=&quot;titleTextSize&quot; format=&quot;dimension&quot; /&gt;  

&lt;declare-styleable name=&quot;CustomTitleView&quot;&gt;  
    &lt;attr name=&quot;titleText&quot; /&gt;  
    &lt;attr name=&quot;titleTextColor&quot; /&gt;  
    &lt;attr name=&quot;titleTextSize&quot; /&gt;  
&lt;/declare-styleable&gt;  

&lt;/resources&gt;  
</code></pre><p>我们定义了文字,颜色和尺寸三种属性.format就是该属性的取值类型;<br>具体属性可百度查找</p>
<p>2.在布局文件中声明我们的自定义View</p>
<pre><code>&lt;RelativeLayout
xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:custom=&quot;http://schemas.android.com/apk/res-auto&quot;
xmlns:tools=&quot;http://schemas.android.com/tools&quot;
android:id=&quot;@+id/activity_main&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
&gt;
&lt;com.loren.customview.view.CustomTitleView
    android:layout_width=&quot;100dp&quot;
    android:layout_height=&quot;50dp&quot;
    android:layout_centerInParent=&quot;true&quot;
    android:padding=&quot;10dp&quot;
    custom:titleColor=&quot;#ff0000&quot;
    custom:titleSize=&quot;40sp&quot;
    custom:titleText=&quot;3712&quot;
    /&gt;
&lt;/RelativeLayout&gt;
</code></pre><p>3.在View的构造方法获取我们的自定义属性</p>
<pre><code>public CustomTitleView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    this.mContext = context;
    initView(attrs,defStyleAttr);
}

private void initView(AttributeSet attrs,int defStyleAttr) {
    //获取我们自定义的attrs样式
    TypedArray typedArray = mContext.getTheme()
            .obtainStyledAttributes(attrs, R.styleable.CustomTitleView, defStyleAttr, 0);
    //定义自定义的控件参数的数目,是在布局文件中使用的;
    int n = typedArray.getIndexCount();
    for (int i = 0; i &lt; n; i++) {
        int attr = typedArray.getIndex(i);
        switch (attr) {
            case R.styleable.CustomTitleView_titleText:
                mTitleText = typedArray.getString(i);
                break;
            case R.styleable.CustomTitleView_titleColor:
                //后一个值为默认颜色
                mTitleColor = typedArray.getColor(i, Color.BLACK);
                break;
            case R.styleable.CustomTitleView_titleSize:
                //获取我们设置的字体大小值,设置默认值为16sp,TypeValue可以将sp转换为px
                mTitleSize = typedArray.getDimensionPixelSize(attr, (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, 16, getResources().getDisplayMetrics()));
                break;
        }
    }
    //使用了TypeArray,所以必须要调用recyele();
    typedArray.recycle();
    mPaint = new Paint();
    mPaint.setTextSize(mTitleSize);
    mBound = new Rect();
    mPaint.getTextBounds(mTitleText, 0, mTitleText.length(), mBound);
    this.setOnClickListener(new OnClickListener() {
        @Override
        public void onClick(View v) {
            mTitleText = createRandomNum();
            postInvalidate();
        }
    });
}
</code></pre><h5 id="重写onMeasure"><a href="#重写onMeasure" class="headerlink" title="重写onMeasure();"></a>重写onMeasure();</h5><p>暂时这个类不做任何操作;  </p>
<h5 id="重写onDraw-画出文字"><a href="#重写onDraw-画出文字" class="headerlink" title="重写onDraw();画出文字"></a>重写onDraw();画出文字</h5><pre><code>@Override
protected void onDraw(Canvas canvas) {
    //画出黄色背景框
    mPaint.setColor(Color.YELLOW);
    canvas.drawRect(0, 0, getMeasuredWidth(), getMeasuredHeight(), mPaint);
    //设置文字的颜色
    mPaint.setColor(mTitleColor);
    canvas.drawText(mTitleText,getWidth()/2 - mBound.width() /2 ,getHeight()/2 + mBound.height()/2,
            mPaint);
}
</code></pre><p>现在实现的效果如下:<br><img width="80%" height="80%" align="center" src="\customView-1\realize_result_2017-3-6.jpg" alt="realize_result_2017-3-6"></p>
<p>这样就基本实现了View的自定义,但是当我们在布局文件中定义了宽度和高度为wrap_content,那么久成这样了:</p>
<p><img width="80%" height="80%" align="center" src="\customView-1\realize_result_2017-3-6_1.png" alt="realize_result_2017-3-6_1"></p>
<p>系统帮我们测量的高度和宽度都是<code>MATCH_PARNET</code>，当我们设置明确的宽度和高度时，系统帮我们测量的结果就是我们设置的结果，当我们设置为<code>WRAP_CONTENT</code>,或者<code>MATCH_PARENT</code>系统帮我们测量的结果就是<code>MATCH_PARENT</code>的长度。<br>所以，当设置了<code>WRAP_CONTENT</code>时，我们需要自己进行测量，即重写<code>onMesure</code>方法”：</p>
<h5 id="重写onMeasure方法"><a href="#重写onMeasure方法" class="headerlink" title="重写onMeasure方法:"></a>重写onMeasure方法:</h5><pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    int widtHSize = MeasureSpec.getSize(widthMeasureSpec);
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    int heightSize = MeasureSpec.getSize(heightMeasureSpec);

    int width;
    int height;

    if(widthMode == MeasureSpec.EXACTLY) {
        width = widtHSize;
    }else {
        mPaint.setTextSize(mDimensionPixelSize);
        mPaint.getTextBounds(mTitleText, 0, mTitleText.length(), mBound);
        float textWidth = mBound.width();
        //如果设置了padding值,就要加上
        int desiredWidth = (int) (getPaddingLeft() + textWidth + getPaddingRight());
        width = desiredWidth;
    }

    if(heightMode == MeasureSpec.EXACTLY) {
        height = heightSize;
    }else {
        mPaint.setTextSize(mDimensionPixelSize);
        mPaint.getTextBounds(mTitleText, 0, mTitleText.length(), mBound);
        int textHeight = mBound.height();
        int desiredHeight = getPaddingTop() + textHeight + getPaddingBottom();
        height = desiredHeight;
    }
    setMeasuredDimension(width,height);
}
</code></pre><p>了解下<code>MeasureSpec的specMode</code>,一共三种类型：<br><strong><code>EXACTLY</code></strong>：一般是设置了明确的值或者是MATCH_PARENT<br><strong><code>AT_MOST</code></strong>：表示子布局限制在一个最大值内，一般为WARP_CONTENT<br><strong><code>UNSPECIFIED</code></strong>：表示子布局想要多大就多大，很少使用   </p>
<pre><code>&lt;com.loren.customview.view.CustomTitleView
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_centerInParent=&quot;true&quot;
    android:padding=&quot;10dp&quot;
    custom:titleColor=&quot;#ff0000&quot;
    custom:titleSize=&quot;40sp&quot;
    custom:titleText=&quot;3712&quot;
    /&gt;
</code></pre><p>完全复合我们的预期，现在我们可以对高度、宽度进行随便的设置了，基本可以满足我们的需求。</p>
<p>最后,我们对我们自定义的TextView添加一个点击控制,没点击一次,改变文字</p>
<p>//添加点击事件</p>
<pre><code>this.setOnClickListener(new OnClickListener() {
        @Override
        public void onClick(View v) {
            mTitleText = createRandomNum();
            //需要调用,让View在工作线程重画
            postInvalidate();
        }
    }); 
</code></pre><p>//生成随机数</p>
<pre><code>private String createRandomNum() {
    Random random = new Random();
    HashSet&lt;Integer&gt; integers = new HashSet&lt;&gt;();
    while (integers.size() &lt; 4) {
        int i = random.nextInt(10);
        integers.add(i);
    }
    StringBuffer stringBuffer = new StringBuffer();
    for (Integer i : integers) {
        stringBuffer.append(&quot;&quot; + i);
    }
    return stringBuffer.toString();
}
</code></pre><p><em>效果就是本文开头的效果了</em></p>
<h3 id="invalidate-和-postInvalidate的区别"><a href="#invalidate-和-postInvalidate的区别" class="headerlink" title="invalidate 和 postInvalidate的区别"></a><code>invalidate</code> 和 <code>postInvalidate</code>的区别</h3><p>Android中实现view的更新有两组方法，一组是<code>invalidate</code>，另一组是<code>postInvalidate</code>，其中前者是在UI线程自身中使用，而后者在非UI线程中使用。<br>在UI主线程中，用<code>invalidate()</code>；本质是调用View的onDraw（）绘制。主线程之外，用<code>postInvalidate()</code>。</p>
<p>区别:<br><code>invalidate()</code>是用来刷新View的，必须是在UI线程中进行工作。比如在修改某个view的显示时，调用<code>invalidate()</code>才能看到重新绘制的界面。<br><code>invalidate()</code>的调用是把之前的旧的view从主UI线程队列中pop掉。 一个Android程序默认情况下也只有一个进程，但一个进程下却可以有许多个线程。<br>在这么多线程当中，把主要是负责控制UI界面的显示、更新和控件交互的线程称为<code>UI线程</code>，由于<code>onCreate()</code>方法是由UI线程执行的，所以也可以把UI线程理解为主线程。其余的线程可以理解为工作者线程。<br><code>invalidate()</code>得在UI线程中被调动，在工作者线程中可以通过Handler来通知UI线程进行界面更新。而<code>postInvalidate()</code>在工作者线程中被调用</p>
<ol>
<li><p>invalidate():实例化一个Handler对象，并重写handleMessage方法调用invalidate()实现界面刷新;而在线程中通过sendMessage发送界面更新消息。</p>
<p> // 在onCreate()中开启线程<br> new Thread(new GameThread()).start();<br> // 实例化一个handler<br> Handler myHandler = new Handler() {<br> // 接收到消息后处理                　　<br> public void handleMessage(Message msg) {</p>
<pre><code>switch (msg.what) {
    case Activity01.REFRESH:
    mGameView.invalidate(); // 刷新界面
    break;
}
    super.handleMessage(msg);
}
};
class GameThread implements Runnable {　
    public void run() {
    while (!Thread.currentThread()                    .isInterrupted()) {
        Message message = new Message();
        message.what = Activity01.REFRESH;
    // 发送消息
            　　　　　　Activity01.this.myHandler.sendMessage(message);
try {
    Thread.sleep(100);
} catch (InterruptedException e) {
    Thread.currentThread().interrupt();
}
</code></pre><p> }<br> }<br> }<br>2.使用postInvalidate则比较简单，不需要handler，直接在线程中调用postInvalidate即可</p>
<p> class GameThread implements Runnable {</p>
<pre><code>public void run() {
    　while (!Thread.currentThread()
            .isInterrupted()) {
            　　try {
    Thread.sleep(100);
} catch (InterruptedException e) {
    Thread.currentThread().interrupt();
    }
    // 使用postInvalidate可以直接在线程中更新界面
            　　　　　　mGameView.postInvalidate();
    }
}
</code></pre><p> }<br>下面我们看一下postInvalidate()的源码:</p>
<p> public void postInvalidate() {</p>
<pre><code>postInvalidateDelayed(0);
</code></pre><p> }<br> public void postInvalidateDelayed(long delayMilliseconds) {</p>
<pre><code>// We try only with the AttachInfo because there&apos;s no point in invalidating
// if we are not attached to our window
if (mAttachInfo != null) {
    Message msg = Message.obtain();
    msg.what = AttachInfo.INVALIDATE_MSG;
    msg.obj = this;
    mAttachInfo.mHandler.sendMessageDelayed(msg, delayMilliseconds);
}
</code></pre><p> }</p>
</li>
</ol>
<p>可以看到,postInvalidate()也是调用了系统的Handler方法;</p>
<h3 id="整个CustomTextView类代码"><a href="#整个CustomTextView类代码" class="headerlink" title="整个CustomTextView类代码:"></a>整个CustomTextView类代码:</h3><pre><code>public class CustomTitleView extends View {
private Context mContext;
private String  mTitleText;
private int     mTitleColor;
private int     mTitleSize;
private Paint   mPaint;
private Rect    mBound;

public CustomTitleView(Context context) {
    this(context,null);
}

public CustomTitleView(Context context, AttributeSet attrs) {
    this(context, attrs,0);
}

public CustomTitleView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    this.mContext = context;
    initView(attrs,defStyleAttr);
}

private void initView(AttributeSet attrs,int defStyleAttr) {
    TypedArray typedArray = mContext.getTheme()
            .obtainStyledAttributes(attrs, R.styleable.CustomTitleView, defStyleAttr, 0);
    int n = typedArray.getIndexCount();
    //TODO 需要删除日志
    Log.d(&quot;50==lo+initView&quot;, n + &quot; &gt;&gt;n--&lt;&lt; &quot;);


    for (int i = 0; i &lt; n; i++) {
        int attr = typedArray.getIndex(i);
        switch (attr) {
            case R.styleable.CustomTitleView_titleText:
                mTitleText = typedArray.getString(i);
                break;
            case R.styleable.CustomTitleView_titleColor:
                mTitleColor = typedArray.getColor(i, Color.BLACK);
                break;
            case R.styleable.CustomTitleView_titleSize:
                mTitleSize = typedArray.getDimensionPixelSize(attr, (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, 16, getResources().getDisplayMetrics()));
                break;
        }
    }
    typedArray.recycle();
    mPaint = new Paint();
    mPaint.setTextSize(mTitleSize);
    mBound = new Rect();
    mPaint.getTextBounds(mTitleText, 0, mTitleText.length(), mBound);
    this.setOnClickListener(new OnClickListener() {
        @Override
        public void onClick(View v) {
            mTitleText = createRandomNum();
            postInvalidate();
        }
    });
}

private String createRandomNum() {
    Random random = new Random();
    HashSet&lt;Integer&gt; integers = new HashSet&lt;&gt;();
    while (integers.size() &lt; 4) {
        int i = random.nextInt(10);
        integers.add(i);
    }
    StringBuffer stringBuffer = new StringBuffer();
    for (Integer i : integers) {
        stringBuffer.append(&quot;&quot; + i);
    }
    return stringBuffer.toString();
}

@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    int widtHSize = MeasureSpec.getSize(widthMeasureSpec);
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    int heightSize = MeasureSpec.getSize(heightMeasureSpec);

    int width;
    int height;

    if(widthMode == MeasureSpec.EXACTLY) {
        width = widtHSize;
    }else {
        mPaint.setTextSize(mTitleSize);
        mPaint.getTextBounds(mTitleText, 0, mTitleText.length(), mBound);
        float textWidth = mBound.width();
        int desiredWidth = (int) (getPaddingLeft() + textWidth + getPaddingRight());
        width = desiredWidth;
    }

    if(heightMode == MeasureSpec.EXACTLY) {
        height = heightSize;
    }else {
        mPaint.setTextSize(mTitleSize);
        mPaint.getTextBounds(mTitleText, 0, mTitleText.length(), mBound);
        int textHeight = mBound.height();
        int desiredHeight = getPaddingTop() + textHeight + getPaddingBottom();
        height = desiredHeight;
    }
    setMeasuredDimension(width,height);
}

@Override
protected void onDraw(Canvas canvas) {
    //画出黄色背景框
    mPaint.setColor(Color.YELLOW);
    canvas.drawRect(0, 0, getMeasuredWidth(), getMeasuredHeight(), mPaint);
    //设置文字的颜色
    mPaint.setColor(mTitleColor);
    canvas.drawText(mTitleText,getWidth()/2 - mBound.width() /2 ,getHeight()/2 + mBound.height()/2,
            mPaint);

}
}
</code></pre><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>关于MeasureSpec的模式类型的一些解释,最简单的映射关系是：</p>
<ul>
<li><code>wrap_parent</code> -&gt; <code>MeasureSpec.AT_MOST</code>  </li>
<li><code>match_parent</code> -&gt; <code>MeasureSpec.EXACTLY</code>  </li>
<li><code>具体值</code> -&gt; <code>MeasureSpec.EXACTLY</code><br>但是上面代码由于放在<code>RelativeLayout</code> 中，<code>RelativeLayout</code> 是一个比较复杂的 <code>ViewGroup</code>，其中子 view 的大小不仅跟 layout_width、layout_height 属性相关，还更很多属性有关系，所以会改变上述映射情况，使结果变得特别复杂。</li>
</ul>
<hr>
<h3 id="参看文档"><a href="#参看文档" class="headerlink" title="参看文档:"></a>参看文档:</h3><p><a href="http://blog.csdn.net/lmj623565791/article/details/24252901" target="_blank" rel="external">Android 自定义View (一)</a><br><a href="http://blog.csdn.net/a2012s/article/details/21156125" target="_blank" rel="external">Android界面刷新—— invalidate与postInvalidate</a><br><a href="http://blog.csdn.net/a396901990/article/details/36475213?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external"> ANDROID自定义视图——onMeasure，MeasureSpec源码 流程 思路详解</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/28/RxBus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lorensong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lorensong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/28/RxBus/" itemprop="url">
                  RxBus实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-28T17:50:01+08:00">
                2017-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hexo/" itemprop="url" rel="index">
                    <span itemprop="name">hexo</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h4 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h4><p>根据EventBus的总线思想,最近在学习Rxjava,尝试使用Rxjava来代替EventBus来实现总线的功能;<br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/28/RxBus/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="lorensong" />
          <p class="site-author-name" itemprop="name">lorensong</p>
           
              <p class="site-description motion-element" itemprop="description">If you love life, life will love you back.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lorensong</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
