<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="RxJava," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="RxJava">
<meta property="og:type" content="article">
<meta property="og:title" content="RxJava入门与基础">
<meta property="og:url" content="http://yoursite.com/2017/02/26/RxJavaBasic/index.html">
<meta property="og:site_name" content="lorensong">
<meta property="og:description" content="RxJava">
<meta property="og:image" content="http://yoursite.com/RxJavaBasic/why_introduces_2017-2-28.png">
<meta property="og:image" content="http://yoursite.com/RxJavaBasic\EventConversion_2017-2-28.jpg">
<meta property="og:image" content="http://yoursite.com/RxJavaBasic/demo_schedulers_2017-3-1.jpg">
<meta property="og:image" content="http://yoursite.com/RxJavaBasic/demo_schedulers_2017-3-1_2.jpg">
<meta property="og:image" content="http://yoursite.com/RxJavaBasic/demo_schedulers_2017-3-1_3.jpg">
<meta property="og:image" content="http://yoursite.com/RxJavaBasic/demo_schedulers_2017-3-1_4.jpg">
<meta property="og:image" content="http://yoursite.com/RxJavaBasic/demo_schedulers_2017-3-1_5.jpg">
<meta property="og:updated_time" content="2017-03-03T08:02:41.197Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RxJava入门与基础">
<meta name="twitter:description" content="RxJava">
<meta name="twitter:image" content="http://yoursite.com/RxJavaBasic/why_introduces_2017-2-28.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/02/26/RxJavaBasic/"/>





  <title> RxJava入门与基础 | lorensong </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lorensong</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">If you love life, life will love you back.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/26/RxJavaBasic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lorensong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lorensong">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                RxJava入门与基础
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-26T12:17:34+08:00">
                2017-02-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h3><a id="more"></a>
<h4 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h4><p>感觉RxJava最近风生水起，不学习一下都不好意思了，洒家也是初学RxJava，也是感觉代码好像更复杂更难懂了，看了一篇外文感同身受，简单翻译一下。本文简单介绍使用RxJava优势所在。但可能需要有一点RxJava基础，推荐先看一下抛物线的那篇经典的匠心写作。<br><img width="80%" height="30%" align="center" src="RxJavaBasic/why_introduces_2017-2-28.png" alt="why_introduces_2017-2-28"></p>
<h4 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h4><p>相信各位看官对RxJava早有耳闻，那么关于什么是RxJava我就不再赘述了，不知道的可自行百度。如果你已经大致了解过什么是RxJava，想开始学习，那么本文不失为你良好的选择，为什么这么说呢，因为我也是刚学几天，正所谓“知己知彼，百战不殆”。网上流传，RxJava的入门门槛高，而经过我这几天的学习，我反而不那么认为，精通我不敢说，但入门确实也不难，不信？我先来个简单的例子预热一下。</p>
<p>先创建个数据发射源,很好理解，就是发射数据用的:  </p>
<pre><code>//创建被观察者
    Observable&lt;String&gt; stringObservable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() {
        @Override
        public void call(Subscriber&lt;? super String&gt; subscriber) {
            subscriber.onNext(&quot;Hello World&quot;);
        }
    });
    //创建订阅者
    mStringSubscriber = new Subscriber&lt;String&gt;(){

        @Override
        public void onCompleted() {
            //完成后调用
        Toast.makeText(MainActivity.this, &quot;结束&quot;, Toast.LENGTH_SHORT)
                    .show();
        }

        @Override
        public void onError(Throwable e) {
            //出现错误时调用
        }

        @Override
        public void onNext(String s) {
            //具体的处理逻辑
            mTv_text.setText(s);

        }
    };
    //产生订阅关系
    stringObservable.subscribe(mStringSubscriber);  
</code></pre><p><strong>注意:</strong><br>在我们订阅了观察者和被观察者后,需要程序相应的onpause或onstop中定义对应的如下代码,保证我们的内存不会泄露;</p>
<pre><code>if (!mStringSubscriber.isUnsubscribed()) {
    mStringSubscriber.unsubscribe();
}
</code></pre><p>这样就形成RxJava一个简单的用法，sender发射”Hi，Weavey！”，将会被receiver的onNext的接收，通过这个例子，也许你会想到“异步”、“观察者模式”，没错，这些都是RxJava所做的事情，并且让他们变得更简单和简洁，而RxJava所有的一切都将围绕这两个点展开，一个是发射数据，一个是接收数据，是不是很通俗易懂？如果你理解了这点或者你已经知道RxJava就是这么一回事，那么恭喜你，你已经一只脚跨进RxJava的大门了，如果不是！！！！那也无所谓，请继续往下看…</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>Observable：发射源，英文释义“可观察的”，在观察者模式中称为“被观察者”或“可观察对象”；</p>
<p>Observer：接收源，英文释义“观察者”，没错！就是观察者模式中的“观察者”，可接收Observable、Subject发射的数据；</p>
<p>Subject：Subject是一个比较特殊的对象，既可充当发射源，也可充当接收源，为避免初学者被混淆，本章将不对Subject做过多的解释和使用，重点放在Observable和Observer上，先把最基本方法的使用学会，后面再学其他的都不是什么问题；</p>
<p>Subscriber：“订阅者”，也是接收源，那它跟Observer有什么区别呢？Subscriber实现了Observer接口，比Observer多了一个最重要的方法unsubscribe( )，用来取消订阅，当你不再想接收数据了，可以调用unsubscribe( )方法停止接收，Observer 在 subscribe() 过程中,最终也会被转换成 Subscriber 对象，一般情况下，建议使用Subscriber作为接收源；</p>
<p>Subscription ：Observable调用subscribe( )方法返回的对象，同样有unsubscribe( )方法，可以用来取消订阅事件；</p>
<p>Action0：RxJava中的一个接口，它只有一个无参call（）方法，且无返回值，同样还有Action1，Action2…Action9等，Action1封装了含有 1 个参的call（）方法，即call（T t），Action2封装了含有 2 个参数的call方法，即call（T1 t1，T2 t2），以此类推；</p>
<p>Func0：与Action0非常相似，也有call（）方法，但是它是有返回值的，同样也有Func0、Func1…Func9;</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><h5 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1.基本用法"></a>1.基本用法</h5><pre><code>//创建被观察者
    Observable&lt;String&gt; stringObservable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() {
        @Override
        public void call(Subscriber&lt;? super String&gt; subscriber) {
            subscriber.onNext(&quot;我是被订阅者1&quot;);
            subscriber.onNext(&quot;我是被订阅者2&quot;);
            //onCompleted()表示事件结束,后面的事件都不会被订阅
            subscriber.onCompleted();
            subscriber.onNext(&quot;我是被订阅者3&quot;);

        }
    });
    //创建订阅者
    mStringSubscriber = new Subscriber&lt;String&gt;(){

        @Override
        public void onCompleted() {
            Toast.makeText(MainActivity.this, &quot;结束&quot;, Toast.LENGTH_SHORT)
                    .show();
        }

        @Override
        public void onError(Throwable e) {

        }

        @Override
        public void onNext(String s) {
            //TODO 需要删除日志
            Log.d(&quot;67==lo+onNext&quot;, s + &quot; &gt;&gt;s--&lt;&lt; &quot;);



        }
    };
    //产生订阅关系
    stringObservable.subscribe(mStringSubscriber);
</code></pre><p><em>注意:</em> 在我们的<code>Observable</code>中我们有三个<code>onNext()</code>方法,但是第三个<code>onNext()</code>前面有<code>onCompleted()</code>,所以在<code>Subscriber</code>中只会打印出前两个<code>onNext()</code>中发过来的数据;<br>输出日志:</p>
<blockquote>
<p>D/67==lo+onNext: 我是被订阅者1 &gt;&gt;s–&lt;&lt;<br>D/67==lo+onNext: 我是被订阅者2 &gt;&gt;s–&lt;&lt;  </p>
</blockquote>
<h5 id="2-简洁用法"><a href="#2-简洁用法" class="headerlink" title="2.简洁用法"></a>2.简洁用法</h5><p>2.1 Observable简洁的用法:<br>是不是觉得仅仅为了打印一个hello world要写这么多代码太啰嗦？我这里主要是为了展示RxJava背后的原理而采用了这种比较啰嗦的写法，RxJava其实提供了很多便捷的函数来帮助我们减少代码。</p>
<p>首先来看看如何简化Observable对象的创建过程。RxJava内置了很多简化创建Observable对象的函数，比如Observable.just就是用来创建只发出一个事件就结束的Observable对象，上面创建Observable对象的构造过程的代码可以简化为一行<br>使用just和form:</p>
<pre><code>//1.使用just
Observable&lt;String&gt; just = Observable.just(&quot;被订阅者1&quot;, &quot;被订阅者2&quot;);  

//2.使用form:
List&lt;String&gt; strings = new ArrayList&lt;&gt;();
strings.add(&quot;被订阅者-form1&quot;);
strings.add(&quot;被订阅者-form2&quot;);
strings.add(&quot;被订阅者-form3&quot;);
Observable&lt;String&gt; from = Observable.from(strings);
</code></pre><p><em>区别：</em>  </p>
<ul>
<li><code>just</code>:发送的是整个对象  </li>
<li><code>form</code>:发送的是内部的每一个数据;<br><code>just()</code>方法也可以传list，发送的是整个list对象，而<code>from()</code>发送的是list的一个item</li>
</ul>
<p>无论是just还是form创建Observable都是将需要发送的消息包装在<code>onNext()</code>方法中,并依次发给观察者,当然,他会自己补上<code>onComplete()</code>事件;<br>例如:<br>1.just例子:  </p>
<pre><code>//有如下集合:
    List&lt;String&gt; asList = Arrays.asList(&quot;the&quot;, &quot;quick&quot;, &quot;brown&quot;, &quot;fox&quot;, &quot;jumped&quot;, &quot;over&quot;, &quot;the&quot;, &quot;lazy&quot;,
            &quot;dog&quot;);
//创建被订阅者
    Observable&lt;List&lt;String&gt;&gt; listObservable = Observable.just(asList);

//创建订阅者
Subscriber&lt;List&lt;String&gt;&gt; listSubscriber = new Subscriber&lt;List&lt;String&gt;&gt;(){

        @Override
        public void onCompleted() {

        }

        @Override
        public void onError(Throwable e) {

        }

        @Override
        public void onNext(List&lt;String&gt; strings) {
            for (String s :strings) {
                Log.d(&quot;109==lo+onNext&quot;, s + &quot; &gt;&gt;s--&lt;&lt; &quot;);
            }

        }
    };
//订阅
listObservable.subscribe(listSubscriber);  
</code></pre><p>输出结果:</p>
<blockquote>
<p>D/109==lo+onNext: the &gt;&gt;s–&lt;&lt;<br>D/109==lo+onNext: quick &gt;&gt;s–&lt;&lt;<br>D/109==lo+onNext: brown &gt;&gt;s–&lt;&lt;<br>D/109==lo+onNext: fox &gt;&gt;s–&lt;&lt;<br>D/109==lo+onNext: jumped &gt;&gt;s–&lt;&lt;<br>D/109==lo+onNext: over &gt;&gt;s–&lt;&lt;<br>D/109==lo+onNext: the &gt;&gt;s–&lt;&lt;<br>D/109==lo+onNext: lazy &gt;&gt;s–&lt;&lt;<br>D/109==lo+onNext: dog &gt;&gt;s–&lt;&lt; </p>
</blockquote>
<p>2.form例子    </p>
<pre><code>//1.创建被订阅者
Observable&lt;String&gt; formListObservable = Observable.from(asList);  

//2.创建订阅者
    mStringSubscriber = new Subscriber&lt;String&gt;(){

        @Override
        public void onCompleted() {
            Toast.makeText(MainActivity.this, &quot;结束&quot;, Toast.LENGTH_SHORT)
                    .show();
        }

        @Override
        public void onError(Throwable e) {

        }

        @Override
        public void onNext(String s) {
            //TODO 需要删除日志
            Log.d(&quot;67==lo+onNext&quot;, s + &quot; &gt;&gt;s--&lt;&lt; &quot;);
        }
    };

    //3.订阅
    formListObservable.subscribe(mStringSubscriber);
</code></pre><p>2.2 Subscriber的简洁用法  </p>
<p>如果我们不关心subscriber是否结束（onComplete())或者发生错误(onError()),subscriber的代码可以简化为以下:<br>只需要nextAction:  </p>
<pre><code>//这里的Action一共有 0~9 个;
Action1&lt;String&gt; stringAction1 = new Action1&lt;String&gt;() {
        @Override
        public void call(String s) {
            //TODO 需要删除日志
            Log.d(&quot;99==lo+call&quot;, s + &quot; &gt;&gt;s--&lt;&lt; &quot;);
        }
    };
//同样我们可以在定义一个Throwableaction;
Action1&lt;Throwable&gt; throwableAction1 = new Action1&lt;Throwable&gt;(){
        @Override
        public void call(Throwable throwable) {
            Log.d(&quot;96==locall&quot;,  throwable.getMessage() + &quot; &gt;&gt;throwable.getMessage()---&lt;&lt; &quot;);
        }
    };

//这样我们再定义一个完成的action;这里的Action0主要就是提供了无返回值的情况;
//可以用来做onCompleted
Action0 completeAction0 = new Action0(){
        @Override
        public void call() {
            Log.d(&quot;104==locall&quot;,  &quot; &gt;&gt;完成了---&lt;&lt; &quot;);
        }
    };
</code></pre><p>这样我们就可以订阅了:</p>
<pre><code>Observable.from(strings).subscribe(nextAction1, throwableAction1, completeAction0);  
</code></pre><p>简单一点可以这样:</p>
<pre><code>Observable.from(strings).subscribe(nextAction1);
</code></pre><h5 id="3-链式调用"><a href="#3-链式调用" class="headerlink" title="3.链式调用"></a>3.链式调用</h5><pre><code>Observable.create(new Observable.OnSubscribe&lt;String&gt;() {
        @Override
        public void call(Subscriber&lt;? super String&gt; subscriber) {
            subscriber.onNext(&quot;English&quot;);
            subscriber.onNext(&quot;Chinese&quot;);
            subscriber.onNext(&quot;JAVA&quot;);
            subscriber.onCompleted();
        }
    }).subscribe(new Subscriber&lt;String&gt;() {
        @Override
        public void onCompleted() {
            showToast(&quot;OK&quot;);
        }
        @Override
        public void onError(Throwable e) {
            showToast(&quot;ERROR&quot;);
        }
        @Override
        public void onNext(String s) {
            Log.d(&quot;151==loonNext&quot;,  s + &quot; &gt;&gt;s---&lt;&lt; &quot;);
        }
    });
</code></pre><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="1-根据用户输入的文字-返回一串拼接好的url链接"><a href="#1-根据用户输入的文字-返回一串拼接好的url链接" class="headerlink" title="1.根据用户输入的文字,返回一串拼接好的url链接:"></a>1.根据用户输入的文字,返回一串拼接好的url链接:</h5><pre><code>private void practice1() {
    Subscriber&lt;List&lt;String&gt;&gt; stringSubscriber = new Subscriber&lt;List&lt;String&gt;&gt;() {
        @Override
        public void onCompleted() {
            Log.d(&quot;129==loonCompleted&quot;,  &quot; &gt;&gt;完成---&lt;&lt; &quot;);
        }

        @Override
        public void onError(Throwable e) {
            e.printStackTrace();
        }

        @Override
        public void onNext(List&lt;String&gt; strings) {
            for (String s : strings) {
                Log.d(&quot;142==loonNext&quot;,  s + &quot; &gt;&gt;s---&lt;&lt; &quot;);
            }
        }

    };

    search(&quot;Android&quot;)
            .subscribe(stringSubscriber);
}

private Observable search(String str) {
    List&lt;String&gt; list = new ArrayList&lt;&gt;();
    list.add(&quot;www.baidu.com/&amp;&quot; + str);
    list.add(&quot;www.sina.com/&amp;&quot; + str);
    list.add(&quot;www.360.cn/&amp;&quot; + str);
    return Observable.just(list);
}
</code></pre><p>现在需要将原来的Android改成Java然后再返回,这样就又需要一个新的操作符了<code>flatmap</code>,先看看是怎么用的.<br>对上面的代码进行部分改动,如下:</p>
<pre><code>search(&quot;Android&quot;)
            .flatMap(new Func1&lt;List&lt;String&gt;,Observable&lt;List&lt;String&gt;&gt;&gt;() {
                @Override
                public Observable&lt;List&lt;String&gt;&gt; call(List&lt;String&gt; o) {
                    for (int i = 0; i &lt; o.size(); i++) {
                        CharSequence replace = TextUtils.replace(o.get(i),new String[]{&quot;Android&quot;}, new
                                CharSequence[]{&quot;java&quot;});
                        o.set(i, replace.toString());
                    }
                    return Observable.just(o);
                }
            })
            .subscribe(stringSubscriber); 
</code></pre><p>输出结果:</p>
<blockquote>
<p>D/140==lo+onNext: www.baidu.com/&amp;java &gt;&gt;s–&lt;&lt;<br>D/140==lo+onNext: www.sina.com/&amp;java &gt;&gt;s–&lt;&lt;<br>D/140==lo+onNext: www.360.cn/&amp;java &gt;&gt;s–&lt;&lt;<br>D/129==loonCompleted:  &gt;&gt;完成—&lt;&lt;   </p>
</blockquote>
<p>有了<code>FlatMap</code>这样的特性,我们就可在<code>flatmap</code>中进行替换等其他需要的操作了,就不用在<code>Observable</code>中进行过多的没有意义的操作;</p>
<p>又有新的需求了(<code>MD需求怎么这么多?</code>),我们在Subscrible中对集合进行了遍历并输出,那么可以采用<code>Flatmap</code>进行操作,原来的代码如下:</p>
<pre><code>private void practice1() {
    Subscriber&lt;String&gt; stringSubscriber = new Subscriber&lt;String&gt;() {
        @Override
        public void onCompleted() {

        }

        @Override
        public void onError(Throwable e) {

        }

        @Override
        public void onNext(String s) {
            Log.d(&quot;160==loonNext&quot;,  s + &quot; &gt;&gt;s---&lt;&lt; &quot;);
        }
    };


    search(&quot;Android&quot;)
            .flatMap(new Func1&lt;List&lt;String&gt;,Observable&lt;List&lt;String&gt;&gt;&gt;() {
                @Override
                public Observable&lt;List&lt;String&gt;&gt; call(List&lt;String&gt; o) {
                    for (int i = 0; i &lt; o.size(); i++) {
                        CharSequence replace = TextUtils.replace(o.get(i),new String[]{&quot;Android&quot;}, new
                                CharSequence[]{&quot;java&quot;});
                        o.set(i, replace.toString());
                    }
                    return Observable.just(o);
                }
            })
            .flatMap(new Func1&lt;List&lt;String&gt;,Observable&lt;String&gt;&gt;() {
                @Override
                public Observable&lt;String&gt; call(List&lt;String&gt; strings) {
                    return Observable.from(strings);
                }

            })
            .subscribe(stringSubscriber);
}

private Observable search(String str) {
    List&lt;String&gt; list = new ArrayList&lt;&gt;();
    list.add(&quot;www.baidu.com/&amp;&quot; + str);
    list.add(&quot;www.sina.com/&amp;&quot; + str);
    list.add(&quot;www.360.cn/&amp;&quot; + str);
    return Observable.just(list);
}  
</code></pre><p><strong>flatmap:</strong>Rxjava的操作符,接收一个Observable对象,然后输出另外一个Observable对象;</p>
<h5 id="事件的变换"><a href="#事件的变换" class="headerlink" title="事件的变换"></a>事件的变换</h5><p>Rxjava中最精彩的地方就是根据我们传入的内容进行<strong>加工变换</strong>可以呈现出不同的形态,都是基于Rxjava的<code>Operator</code>来实现的;<br><img width="30%" height="50%" src="RxJavaBasic\EventConversion_2017-2-28.jpg" alt="EventConversion_2017-2-28" align="center"><br>这里就是给事件添加过滤操作.</p>
<h5 id="1-开关事件-过滤到返回值是false的"><a href="#1-开关事件-过滤到返回值是false的" class="headerlink" title="1. 开关事件,过滤到返回值是false的"></a>1. 开关事件,过滤到返回值是false的</h5><pre><code>private void switchEvent() {
    Observable.just(&quot;on&quot;,&quot;off&quot;,&quot;on&quot;,&quot;off&quot;,&quot;on&quot;)
            .filter(new Func1&lt;String, Boolean&gt;() {
                @Override
                public Boolean call(String s) {
                    //只有满足的才会返回,不满足的就过滤掉;
                    return TextUtils.equals(&quot;on&quot;, s);
                }
            })
            .subscribe(new Action1&lt;String&gt;() {
                @Override
                public void call(String s) {
                    Log.d(&quot;140==locall&quot;,  s + &quot; &gt;&gt;s---&lt;&lt; &quot;);
                }
            });
}
</code></pre><p>结果如下:</p>
<blockquote>
<p>D/140==locall: on &gt;&gt;s—&lt;&lt;<br>D/140==locall: on &gt;&gt;s—&lt;&lt;<br>D/140==locall: on &gt;&gt;s—&lt;&lt;  </p>
</blockquote>
<p><strong>filter:</strong> 操作符,主要用于事件的变换和过滤操作;</p>
<h5 id="2-去掉单词中的重复字符"><a href="#2-去掉单词中的重复字符" class="headerlink" title="2. 去掉单词中的重复字符"></a>2. 去掉单词中的重复字符</h5><pre><code>private void clearRepetition() {
    Subscriber&lt;String&gt; stringSubscriber = new Subscriber&lt;String&gt;() {
        @Override
        public void onCompleted() {

        }

        @Override
        public void onError(Throwable e) {

        }

        @Override
        public void onNext(String s) {
            Log.d(&quot;145==loonNext&quot;,  s + &quot; &gt;&gt;s---&lt;&lt; &quot;);
        }
    };

    List&lt;String&gt; strings = Arrays.asList(&quot;the&quot;, &quot;quick&quot;, &quot;brown&quot;, &quot;fox&quot;, &quot;jumped&quot;, &quot;over&quot;, &quot;the&quot;, &quot;lazy&quot;, &quot;dog&quot;);
    Observable.from(strings)
            .flatMap(new Func1&lt;String, Observable&lt;String&gt;&gt;() {
                @Override
                public Observable&lt;String&gt; call(String s) {

                    return Observable.from(s.split(&quot;&quot;));
                }
            })
            .distinct()
            .zipWith(Observable.range(1, Integer.MAX_VALUE), new Func2&lt;String, Integer, String&gt;() {
                @Override
                public String call(String s, Integer integer) {

                    return String.format(&quot;%2d. %s&quot;, integer, s);
                }
            })
            .subscribe(stringSubscriber);
}
</code></pre><p>输出结果:  </p>
<blockquote>
<p>D/145==loonNext:  1.  &gt;&gt;s—&lt;&lt;<br>D/145==loonNext:  2. t &gt;&gt;s—&lt;&lt;<br>D/145==loonNext:  3. h &gt;&gt;s—&lt;&lt;<br>……<br>D/145==loonNext: 25. y &gt;&gt;s—&lt;&lt;<br>D/145==loonNext: 26. g &gt;&gt;s—&lt;&lt;  </p>
</blockquote>
<p><strong>distinct:</strong> 操作符,用于去除发送的数据是否重复,如果重复,就过滤;<br><strong>zipWith:</strong> 操作符,第一个参数是另一个参数的被观察者,具体见另RxJava操作符;</p>
<h5 id="3-将一个string字符串转换为Integer类型-然后再转化为string"><a href="#3-将一个string字符串转换为Integer类型-然后再转化为string" class="headerlink" title="3.将一个string字符串转换为Integer类型,然后再转化为string;"></a>3.将一个string字符串转换为Integer类型,然后再转化为string;</h5><pre><code>private void mapOperator() {
    final String text = &quot;Hello Map Operator&quot;;
    Subscriber&lt;String&gt; stringSubscriber = new Subscriber&lt;String&gt;() {
        @Override
        public void onCompleted() {

        }

        @Override
        public void onError(Throwable e) {

        }

        @Override
        public void onNext(String s) {

        }
    };

    Observable.just(text)
            .map(new Func1&lt;String, Integer&gt;() {
                @Override
                public Integer call(String s) {

                    return s.length();
                }
            })
            .map(new Func1&lt;Integer, String&gt;() {
                @Override
                public String call(Integer integer) {
                    return integer + &quot;&quot;;
                }
            })
            .subscribe(stringSubscriber);

}
</code></pre><p><strong>map:</strong>操作符,接收输入的是Observable对象,而返回出去的也是Observable;</p>
<p><strong>注意:</strong>flatmap和map操作符的区别,会在下一篇文章中说明;</p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子:"></a>例子:</h4><h5 id="1-完成以下需求"><a href="#1-完成以下需求" class="headerlink" title="1.完成以下需求"></a>1.完成以下需求</h5><p>1-1.从服务器拿去10张图片<br>1-2.去除重复的url地址;<br>1-3.剔除p13.jpg的图片;<br>1-4.只获取3张图片;<br>1-5.把接收到的数据都设置到一个集合当中;<br>1-6.在完成阶段(onCompleted)将数据存入到Adapter中并展示;  </p>
<pre><code>//拼接10张图片的url地址;
final ArrayList&lt;CatBean&gt; catBeens = new ArrayList&lt;&gt;();
    for (int i = 0; i &lt; 10; i++) {
        String url = Constant.SERVER_HOST + &quot;p1&quot; + i % 5 + &quot;.jpg&quot;;
        catBeens.add(new CatBean(url, url));
    }
mMyCatBeen = new ArrayList&lt;&gt;();
//创建一个Observable对象;
Observable.create(new Observable.OnSubscribe&lt;String&gt;() {
        @Override
        public void call(Subscriber&lt;? super String&gt; subscriber) {
            for (int i = 0; i &lt; catBeens.size(); i++) {
                subscriber.onNext(catBeens.get(i).getHeadImage());
            }
            subscriber.onCompleted();
        }
    })
        .distinct()//去除重复的字符串;
        .filter(new Func1&lt;String, Boolean&gt;() {//在这个里面做操作,如果条件满足条件才会返回;
            @Override
            public Boolean call(String s) {
                return !s.endsWith(&quot;p13.jpg&quot;);//剔除p13的图片;
            }
        })
            .take(3)//只需要获取3张图片
            //后面说明doOnNext();的用处
            .doOnNext(new Action1&lt;String&gt;() {
             @Override
             public void call(String s) {
                 save(s); //用来保存s;
             }
            }) {
        }
            .subscribe(new Subscriber&lt;String&gt;() {
        @Override
        public void onCompleted() {
            //结束之后,将数据全部存放到adapter中并显示;
            mLvActRxjava.setAdapter(new MyAdapter&lt;CatBean&gt;(mContext,mMyCatBeen));
        }
        @Override
        public void onError(Throwable e) {
        }
        @Override
        public void onNext(String s) {
            Log.d(&quot;181==loonNext&quot;,  s + &quot; &gt;&gt;s---&lt;&lt; &quot;);
            //将每个事件都添加到集合当中去;
            mMyCatBeen.add(new CatBean(s,s));
        }
    });
</code></pre><p><strong>注意:</strong>上面代码中,多了一个<code>doOnNext()</code>;<br>其实,类似<code>doOn...</code>的代码在Rxjava中的操作符很常见,比如还有<code>doOnCompleted</code>,<code>doOnError</code> 等;这些带do的操作符,可以理解为是给Observable的生命周期的各个阶段添一系列的回调监听，当Observable执行到这个阶段的时候，回调就会触发。<br>如这里的:doOnNext();允许我们在每次输出一个元素之前做一些额外的事情;<br>比如:<code>doOnEach</code>,就是Observable每发射一个数据的时候<em>都会触发这个回调</em>，不仅包括onNext还包括OnError和OnCompleted,而这里的doOnNext()和doOnEach类似，区别就在于它只在onNext的时候被触发。</p>
<p><strong>注意</strong>:这里的doOn… 仅仅是side effert,不会改变数据流;</p>
<p>RxJava包含了大量的操作符。操作符的数量是有点吓人 <a href="http://reactivex.io/documentation/operators.html" target="_blank" rel="external">点我去官网</a> ，但是很值得你去挨个看一下，这样你可以知道有哪些操作符可以使用。弄懂这些操作符可能会花一些时间，但是一旦弄懂了，你就完全掌握了RxJava的威力。<br>同时,操作符,我们还可以自定义的,这些内容将放在我的RxJava操作符的文章中;<br>以上的变化的原理都是基于:<code>lift()</code>来实现的,关于<code>lift()</code>的原理,这里就不做延伸了;</p>
<h4 id="RxJava多线程和异步处理"><a href="#RxJava多线程和异步处理" class="headerlink" title="RxJava多线程和异步处理"></a>RxJava多线程和异步处理</h4><p>1.以上实现了一次Rxjava简单的使用,但是这样并没有什么卵用,因为这里我们并没有指定线程,所以这里所定义的Rxjava的使用都是在同一个线程中的.那么实现Rxjava的多线程的调用(异步处理)呢?<br>2.在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 <code>Scheduler</code> （调度器）。  </p>
<p>0.先介绍一下异步的环境和Scheduler的部分API:<br><img width="80%" height="40%" align="center" src="RxJavaBasic/demo_schedulers_2017-3-1.jpg" alt="demo_schedulers_2017-3-1">　　</p>
<p>在RxJava 中，Scheduler ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 Scheduler ，它们已经适合大多数的使用场景：</p>
<p>Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。<br>Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。<br>Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。<br>Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。<br>另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。<br>有了这几个 Scheduler ，就可以使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制了。 <em> subscribeOn(): 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。 </em> observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。</p>
<p>1.最简单的一个例子：　　</p>
<pre><code>//最简短的一个例子:
Observable.just(1, 2, 3, 4)  
.subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程  
.observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程  
.subscribe(new Action1&lt;Integer&gt;() {  
    @Override  
    public void call(Integer number) {  
        Log.d(tag, &quot;number:&quot; + number);  //这里的输出就是在主线程中实现的;
    }  
}); 　　　
</code></pre><p>上面的写法非常的常见,它适用于多数的<strong>[后台线程取数据，主线程显示]</strong>的程序策略。</p>
<p>如下面获取图片和显示图片的例子，获取图片是在子线程做的,设置图片是在主线程中;</p>
<pre><code>//添加了异步处理,把耗时操作放在子线程中完成;
private void initSubscribeDrawable() {
    final int drawableRes = R.mipmap.chrome_dragon;
    //创建一个被观察者,订阅观察者;
    Observable.create(new Observable.OnSubscribe&lt;Drawable&gt;() {
        @Override
        public void call(Subscriber&lt;? super Drawable&gt; subscriber) {
            Drawable drawable = getTheme().getDrawable(drawableRes);
            subscriber.onNext(drawable);
            subscriber.onCompleted();
        }
    })      //这里是在子线程中获取图片的数据,无论子线程中耗时有多少,都不会造成程序的卡顿;
            .subscribeOn(Schedulers.io())//在子线程计算,指定Subscribe的回调在IO线程,指定事件产生的线程.
            .observeOn(AndroidSchedulers.mainThread())//然后切换到主线程;指定Subscriber的回调在主线程;指定事件消费的线程;
            .subscribe(new Subscriber&lt;Drawable&gt;() {
                @Override
                public void onCompleted() {
                    showToast(&quot;完成了&quot;);
                }
                @Override
                public void onError(Throwable e) {
                    showToast(&quot;error&quot;);
                }
                @Override
                public void onNext(Drawable drawable) {
                    mIvActRxjavaPic.setImageDrawable(drawable);//设置图片被放在了主线程;
                }
            });
}



Observable.create(new Observable.OnSubscribe&lt;String&gt;() {
        @Override
        public void call(Subscriber&lt;? super String&gt; subscriber) {
            subscriber.onNext(getFilePath());//获取到String 类型的path;
            subscriber.onCompleted();
        }
    })
            .subscribeOn(Schedulers.newThread())//让被观察者在新开的线程中运行;
            .observeOn(Schedulers.io())//观察者在io线程中观察;
            .map(mapOperator)//通过mapOperator定义的方法过滤对象，事件变换在上面指定的ｉｏ线程;
            .observeOn(AndroidSchedulers.mainThread())//让观察者在主线程中运行;
            .subscribe(booleanSubscriber);//订阅事件;
</code></pre><p>深入理解线程：</p>
<pre><code>//代码中有如下的线程控制:
Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定
.subscribeOn(Schedulers.io())
.observeOn(Schedulers.newThread())
.map(mapOperator) // 新线程，由 observeOn() 指定
.observeOn(Schedulers.io())
.map(mapOperator2) // IO 线程，由 observeOn() 指定
.observeOn(AndroidSchedulers.mainThread) 
.subscribe(subscriber);  // Android 主线程，由 observeOn() 指定
</code></pre><p>对比一下: <code>observeOn()</code>和<code>subscriberOn()</code>的区别:</p>
<p>－　subscribeOn（）它指示Observable在一个指定的调度器上创建（只作用于被观察者创建阶段）。只能指定一次，如果指定多次则以第一次为准.　　　</p>
<p>－　observeOn（）指定在事件传递（加工变换）和最终被处理（观察者）的发生在哪一个调度器。可指定多次，每次指定完都在下一步生效</p>
<p>原理图:</p>
<p><img width="50%" height="50%" align="left" src="RxJavaBasic/demo_schedulers_2017-3-1_2.jpg" alt="demo_schedulers_2017-3-1_2">　  </p>
<p><img width="50%" height="44%" align="right" src="RxJavaBasic/demo_schedulers_2017-3-1_3.jpg" alt="demo_schedulers_2017-3-1_3">　</p>
<p> 不同的是， <code>subscribeOn()</code> 的线程切换发生在 <code>OnSubscribe</code> 中，即在它通知上一级 <code>OnSubscribe</code> 时，这时事件还没有开始发送，因此 <code>subscribeOn()</code> 的线程控制可以从事件发出的开端就造成影响；</p>
<p>而 <code>observeOn()</code> 的线程切换则发生在它内建的 <code>Subscriber</code> 中，即发生在它即将给下一级 Subscriber 发送事件时，因此 observeOn() 控制的是它后面的线程。</p>
<p>下面分析一下,subscribeOn和observeOn混合使用的情况:</p>
<p><img width="100%" height="50%" align="right" src="RxJavaBasic/demo_schedulers_2017-3-1_4.jpg" alt="demo_schedulers_2017-3-1_4">　</p>
<p><strong>doOnSubscribe()</strong><br>在前面讲 Subscriber 的时候，提到过 <code>Subscriber</code> 的 <code>onStart()</code> 可以用作流程开始前的初始化。然而 <code>onStart()</code> 由于在 <code>subscribe()</code> 发生时就被调用了，因此<em>不能指定线程</em>，而是只能执行在 <code>subscribe()</code> 被调用时的线程。这就导致如果 <code>onStart()</code> 中含有对线程有要求的代码（例如在界面上显示一个 ProgressBar，这必须在主线程执行），将会有线程非法的风险，因为有时你无法预测 <code>subscribe()</code> 将会在什么线程执行。</p>
<p>而与 Subscriber.onStart() 相对应的，有一个方法 <code>Observable.doOnSubscribe()</code> 。它和 Subscriber.onStart() 同样是在 subscribe()调用后而且在事件发送前执行，但区别在于它可以指定线程。<strong>默认</strong>情况下， <code>doOnSubscribe()</code> 执行在 <code>subscribe()</code> 发生的线程；而如果在 <code>doOnSubscribe()</code> 之后有 <code>subscribeOn()</code> 的话，它将执行在离它最近的 <code>subscribeOn()</code> 所指定的线程。</p>
<pre><code>Observable.create(onSubscribe)
.subscribeOn(Schedulers.io())
.doOnSubscribe(new Action0() {
    @Override
    public void call() {
        progressBar.setVisibility(View.VISIBLE); // 需要在主线程执行,离他最近的就是下面的subscribeOn();指定的主线程;
    }
})
.subscribeOn(AndroidSchedulers.mainThread()) // 指定主线程
.observeOn(AndroidSchedulers.mainThread())
.subscribe(subscriber);
</code></pre><p>再有一个例子:</p>
<pre><code>//有如下代码:
Observable.create(...)
.lift1(...)
.subscribeOn(scheduler1)
.lift2(...)
.observeOn(scheduler2)
.lift3(...)
.subscribeOn(scheduler3)
.lift4(...)
.observeOn(scheduler4)
.doOnSubscribe(...)
.subscribeOn(scheduler5)
.observeOn(scheduler6)
.subscribe(...);

那么在这段代码中：
lift1, lift2, lift3, lift4指定的代码分别在哪个线程执行？
doOnSubscribe指定的代码在哪个线程执行？
产生事件的代码（create指定的代码）在哪个线程执行？
消费事件的代码（subscribe指定的代码）在哪个线程执行？
</code></pre><p>执行过程可以理解成这样:</p>
<p><img width="80%" height="50%" align="center" src="RxJavaBasic/demo_schedulers_2017-3-1_5.jpg" alt="demo_schedulers_2017-3-1_5">　</p>
<p>上面这幅图表达了一个典型的RxJava调用链中控制流的传递过程。它可以分成两个阶段：  </p>
<p><strong>驱动阶段:</strong>整个异步事件流的触发由subscribe开始。它发起了一个反向驱动过程（从下游到上游），跨过每一个中间的Observable和OnSubscribe，到达第一个Observable（产生事件的源头）。对应图中的(1)和(2)。这个阶段一般就是从下游到上游调用一次就结束了。<br><strong>事件发射阶段:</strong>第一个Observable开始产生事件，然后事件流就开始正向传递，经过每一个中间的Observable，最终到达Subscriber（事件的消费者）。对应图中的(3)。与前一阶段不同，事件从上游往下游传递，不是一次就完了，而是多个事件组成的事件流。<br>我们分析一下这整个流程，其中有几点需要特别说明一下（注：这里的分析过程涉及RxJava的一些实现细节，如不关心细节可以跳过这一段，直接看后面的结论）：</p>
<p>图中的(1)对应的是调用前一级Observable的OnSubscribe.call，是个无返回值的方法，因此可以切换线程，从而变为异步的。所以用虚线表示。<br>图中的(2)对应的是lift操作指定的Operator.call，是个有返回值的方法（输入一个Subscriber，返回一个新的Subscriber）。因此，它只能同步调用，不能切换线程。所以用实线表示。<br>图中的(3)对应的是调用后一级Observable对应的Subscriber（onNext, onCompleted, onError），也都是无返回值的方法，因此可以切换线程，从而变为异步的。所以也用虚线表示。<br>observeOn是基于lift实现的，且切换线程的动作发生在Subscriber（onNext, onCompleted, onError），因此它影响(3)流程上在它下游的所有lift变换。 </p>
<p>subscribeOn不是基于lift实现的，它直接在调用前一级Observable的OnSubscribe时切换线程。因此，它影响(1)流程上在它上游的所有OnSubscribe调用，直到产生事件的源头；然后，(3)流程上的所有lift操作也会在新切换到的线程上，直到碰到一个observeOn操作。<br>doOnSubscribe稍微特殊一点。它虽然是基于lift实现的，但它所指定的代码发生在Operator.call中，不像其它的lift操作，它们指定的代码发生在Subscriber。因此它的执行线程受它下游的subscribeOn的影响。  </p>
<p>结合上面的分析，我们沿着前面流程图中箭头所指的方向一路走过去：</p>
<p>首先从调用subscribe方法开始，沿着前面流程图中的(1)-&gt;(2)-&gt;(1)-&gt;(2)…-&gt;(1)路径（即驱动阶段），从下游向上游回溯，每经过一个subscribeOn，线程就切换一次；每次切换的线程环境影响这一路径上后面（即上游）的doOnSubscribe指定的代码和产生事件的代码（create指定的代码）。<br>经过事件的源头（create指定的代码），转而进入事件发射阶段。<br>然后，再沿着(3)路径（即事件发射阶段），从上游到下游，每经过一个observeOn，线程就切换一次；每次切换的线程环境影响这一路径上后面（即下游）的所有lift操作，直至消费事件的代码（subscribe指定的代码）。<br>现在，把前面的描述换一种说法，就很容易得到下面的结论了：</p>
<p>doOnSubscribe指定的代码和产生事件的代码（create指定的代码），在它们下游最近的一个subscribeOn指定的Scheduler上执行；如果它们下游没有subscribeOn了，那么它们就在调用subscribe方法的那一个线程上执行（注意：是调用subscribe方法的那一个线程，不是subscribe指定的代码执行的那个线程，这是两回事）。<br>普通的lift操作（比如filter, map, reduce等）和消费事件的代码（subscribe指定的代码），在它们上游最近的一个observeOn指定的Scheduler上执行；如果它们上游没有observeOn了，那么它们就在位于整个调用链最上游的第一个subscribeOn指定的Scheduler上执行；如果没找到subscribeOn调用，那么它们就在调用subscribe方法的那一个线程上执行。<br>把这些结论应用在本文开始的那段代码上，我们很快能得到：</p>
<p>产生事件的代码（create指定的代码）在scheduler1上执行；<br>lift1和lift2指定的代码在scheduler1上执行；<br>lift3和lift4指定的代码在scheduler2上执行；<br>doOnSubscribe指定的代码在scheduler5上执行；<br>消费事件的代码（subscribe指定的代码）在scheduler6上执行。 </p>
<h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><hr>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="http://reactivex.io/" target="_blank" rel="external">reactivex官网</a><br><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/" target="_blank" rel="external">ReactiveX中文文档</a><br><a href="http://www.jianshu.com/p/5e93c9101dc5" target="_blank" rel="external">我所理解的RxJava——上手其实很简单</a><br><a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">给 Android 开发者的 RxJava 详解</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0429/4196.html" target="_blank" rel="external">用工厂流水线的方式来理解 RxJava 的概念</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0430/2815.html" target="_blank" rel="external">泡在网上的日子的Rxjava合集</a><br><a href="http://zhangtielei.com/posts/blog-rxandroid-schedulers.html" target="_blank" rel="external">用一张图解释RxJava中的线程控制</a><br><a href="http://www.jianshu.com/p/d7d2d1a664ca" target="_blank" rel="external">RxJava学习 - 初步了解</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/RxJava/" rel="tag"># RxJava</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/24/hexo-gitpage建站实录/" rel="next" title="hexo+gitpage建站实录">
                <i class="fa fa-chevron-left"></i> hexo+gitpage建站实录
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/02/26/Git/" rel="prev" title="Git从入门到放弃">
                Git从入门到放弃 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="lorensong" />
          <p class="site-author-name" itemprop="name">lorensong</p>
           
              <p class="site-description motion-element" itemprop="description">If you love life, life will love you back.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#RxJava"><span class="nav-number">1.</span> <span class="nav-text">RxJava</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Why"><span class="nav-number">1.1.</span> <span class="nav-text">Why?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hello-World"><span class="nav-number">1.2.</span> <span class="nav-text">Hello World</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本概念"><span class="nav-number">1.3.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本用法"><span class="nav-number">1.4.</span> <span class="nav-text">基本用法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-基本用法"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.基本用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-简洁用法"><span class="nav-number">1.4.2.</span> <span class="nav-text">2.简洁用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-链式调用"><span class="nav-number">1.4.3.</span> <span class="nav-text">3.链式调用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例子"><span class="nav-number">1.5.</span> <span class="nav-text">例子</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-根据用户输入的文字-返回一串拼接好的url链接"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.根据用户输入的文字,返回一串拼接好的url链接:</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#事件的变换"><span class="nav-number">1.5.2.</span> <span class="nav-text">事件的变换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-开关事件-过滤到返回值是false的"><span class="nav-number">1.5.3.</span> <span class="nav-text">1. 开关事件,过滤到返回值是false的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-去掉单词中的重复字符"><span class="nav-number">1.5.4.</span> <span class="nav-text">2. 去掉单词中的重复字符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-将一个string字符串转换为Integer类型-然后再转化为string"><span class="nav-number">1.5.5.</span> <span class="nav-text">3.将一个string字符串转换为Integer类型,然后再转化为string;</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例子-1"><span class="nav-number">1.6.</span> <span class="nav-text">例子:</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-完成以下需求"><span class="nav-number">1.6.1.</span> <span class="nav-text">1.完成以下需求</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RxJava多线程和异步处理"><span class="nav-number">1.7.</span> <span class="nav-text">RxJava多线程和异步处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结束"><span class="nav-number">1.8.</span> <span class="nav-text">结束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考文档"><span class="nav-number">1.9.</span> <span class="nav-text">参考文档</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lorensong</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
